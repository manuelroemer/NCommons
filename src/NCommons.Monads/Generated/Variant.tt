<#
    // Recommendation:
    // Don't edit this file in Visual Studio. Download VS Code and this extension:
    // https://marketplace.visualstudio.com/items?itemName=zbecknell.t4-support
#>
<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file=".\..\CodeGen\Generics.tt" #>
<#@ include file=".\..\CodeGen\Ordinals.tt" #>
<#
const int From = 1;
const int To = 8;
#>
// This code has been auto-generated by the associated .tt file.
// Any changes made to in this file will be lost when the file is regenerated.

// Performance notes:
// Each method accepting a Variant should use the "in" modifier.
// There are situations where a Variant is less than IntPtr.Size (e.g. Variant<byte>), but these
// are very uncommon. In most situations, a Variant will have AT LEAST two type parameters and
// will furthermore wrap a reference type. Therefore, the struct's size will almost always exceed
// IntPtr.Size.

namespace NCommons.Monads
{
    using System;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.Diagnostics.CodeAnalysis;
    using NCommons.Monads.Resources;

<#
    for (var currentTo = From; currentTo <= To; currentTo++) {
#>

    public readonly struct Variant<#=TDefinition(currentTo)#> : IEquatable<Variant<#=TDefinition(currentTo)#>>
    {

        internal enum VariantType : byte
        {
            Empty = 0,
<#
        for (var i = From; i <= currentTo; i++) {
#>
            <#=T(i)#> = <#=i#>,
<#
        }
#>
        }

        private static readonly Variant<#=TDefinition(currentTo)#> _empty = new Variant<#=TDefinition(currentTo)#>();
<#
        for (var i = From; i <= currentTo; i++) {
#>
        internal readonly <#=T(i)#> _value<#=i#>; 
<#
        }
#>
        internal readonly VariantType _type;

        public static ref readonly Variant<#=TDefinition(currentTo)#> Empty => ref _empty;

        public bool IsEmpty => _type == VariantType.Empty;

<#
        for (var i = From; i <= currentTo; i++) {
#>
        public bool Is<#=LongOrdinal(i)#> => _type == VariantType.<#=T(i)#>;

        public Optional<<#=T(i)#>> <#=LongOrdinal(i)#> => Is<#=LongOrdinal(i)#> ? _value<#=i#> : Optional<<#=T(i)#>>.Empty;

<#
        }
#>
        public Optional<object?> Value => _type switch
        {
<#
        for (var i = From; i <= currentTo; i++) {
#>
            VariantType.<#=T(i)#> => _value<#=i#>,
<#
        }
#>
            _ => Optional<object?>.Empty
        };
        
<#
        for (var i = From; i <= currentTo; i++) {
#>
        public Variant(<#=T(i)#> value)
        {
            _type = VariantType.<#=T(i)#>;
            _value<#=i#> = value;
<#
        for (var j = From; j <= currentTo; j++) {
            if (i != j) {
#>
            _value<#=j#> = default!;
<#
            }
        }
#>
        }

<#
    }
#>
<#
        for (var i = From; i <= currentTo; i++) {
#>
        public T<#=i#> Get<#=LongOrdinal(i)#>()
        {
            if (!Is<#=LongOrdinal(i)#>)
            {
                throw new InvalidOperationException(ExceptionStrings.Variant_GetValue_HoldsOtherType);
            }
            return _value<#=i#>;
        }

        [return: MaybeNull]
        public T<#=i#> Get<#=LongOrdinal(i)#>OrDefault()
        {
            return _value<#=i#>;
        }

        public T<#=i#> Get<#=LongOrdinal(i)#>Or(<#=T(i)#> substitute)
        {
            return Is<#=LongOrdinal(i)#> ? _value<#=i#> : substitute;
        }

        public T<#=i#> Get<#=LongOrdinal(i)#>Or(Func<<#=T(i)#>> substituteProvider)
        {
            _ = substituteProvider ?? throw new ArgumentNullException(nameof(substituteProvider));
            return Is<#=LongOrdinal(i)#> ? _value<#=i#> : substituteProvider();
        }

        public bool TryGet<#=LongOrdinal(i)#>(out <#=T(i)#> value)
        {
            value = _value<#=i#>;
            return Is<#=LongOrdinal(i)#>;
        }

        public Variant<<#=$"{(i > 1 ? $"{TList(From, i - 1)}, " : "")}TResult{(i < currentTo ? $", {TList(i + 1, currentTo)}" : "")}"#>> Map<#=LongOrdinal(i)#><TResult>(Func<<#=T(i)#>, TResult> map<#=LongOrdinal(i)#>)
        {
            _ = map<#=LongOrdinal(i)#> ?? throw new ArgumentNullException(nameof(map<#=LongOrdinal(i)#>));
            
            return _type switch
            {
<#
            for (var j = From; j <= currentTo; j++) {
                if (i == j) continue;
#>
                VariantType.<#=T(j)#> => _value<#=j#>,
<#
            }
#>
                VariantType.<#=T(i)#> => map<#=LongOrdinal(i)#>(_value<#=i#>),
                _ => Variant<<#=$"{(i > 1 ? $"{TList(From, i - 1)}, " : "")}TResult{(i < currentTo ? $", {TList(i + 1, currentTo)}" : "")}"#>>.Empty
            };
        }

        public Variant<#=TDefinition(currentTo)#> If<#=LongOrdinal(i)#>(Action<<#=T(i)#>> on<#=LongOrdinal(i)#>)
        {
            _ = on<#=LongOrdinal(i)#> ?? throw new ArgumentNullException(nameof(on<#=LongOrdinal(i)#>));
            if (Is<#=LongOrdinal(i)#>)
            {
                on<#=LongOrdinal(i)#>(_value<#=i#>);
            }
            return this;
        }

<#
        }
#>
        public Variant<#=TDefinition(currentTo)#> IfEmpty(Action onEmpty)
        {
            _ = onEmpty ?? throw new ArgumentNullException(nameof(onEmpty));
            if (IsEmpty)
            {
                onEmpty();
            }
            return this;
        }

        public void Match(<#=TParameters(currentTo, index => $"Action<{T(index)}> on{LongOrdinal(index)}")#>, Action onEmpty)
        {
<#
        for (var i = From; i <= currentTo; i++) {
#>
            _ = on<#=LongOrdinal(i)#> ?? throw new ArgumentNullException(nameof(on<#=LongOrdinal(i)#>));
<#
        }
#>
            _ = onEmpty ?? throw new ArgumentNullException(nameof(onEmpty));

            switch (_type)
            {
<#
        for (var i = From; i <= currentTo; i++) {
#>
                case VariantType.<#=T(i)#>:
                    on<#=LongOrdinal(i)#>(_value<#=i#>);
                    break;
<#
}
#>
                default:
                    onEmpty();
                    break;
            };
        }

        public TResult Match<TResult>(<#=TParameters(currentTo, index => $"Func<{T(index)}, TResult> on{LongOrdinal(index)}")#>, Func<TResult> onEmpty)
        {
<#
        for (var i = From; i <= currentTo; i++) {
#>
            _ = on<#=LongOrdinal(i)#> ?? throw new ArgumentNullException(nameof(on<#=LongOrdinal(i)#>));
<#
        }
#>
            _ = onEmpty ?? throw new ArgumentNullException(nameof(onEmpty));

            return _type switch
            {
<#
        for (var i = From; i <= currentTo; i++) {
#>
                VariantType.<#=T(i)#> => on<#=LongOrdinal(i)#>(_value<#=i#>),
<#
}
#>
                _ => onEmpty()
            };
        }

        public override bool Equals(object? obj)
        {
            return obj switch
            {
                Variant<#=TDefinition(currentTo)#> other => Equals(other),
                _ => false
            };
        }

        bool IEquatable<Variant<#=TDefinition(currentTo)#>>.Equals(Variant<#=TDefinition(currentTo)#> other)
        {
            return Equals(in other);
        }

        public bool Equals(in Variant<#=TDefinition(currentTo)#> other)
        {
            if (_type != other._type)
            {
                return false;
            }

            // The two variants hold a value of the same type at this point.
            if (IsEmpty)
            {
                return true;
            }

            return _type switch
            {
<#
        for (var i = 1; i <= currentTo; i++) {
#>
                VariantType.<#=T(i)#> => EqualityComparer<<#=T(i)#>>.Default.Equals(_value<#=i#>, other._value<#=i#>),
<#
        }
#>
                _ => false
            };
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        public override string? ToString()
        {
            return Value.ToString();
        }
        
<#
        if (currentTo == 1) {
#>
        public Optional<T1> ToOptional()
        {
            return IsFirst ? new Optional<T1>(_value1) : Optional<T1>.Empty; 
        }

<#
        }
#>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public void Deconstruct(<#=TParameters(currentTo, index => $"out Optional<{T(index)}> value{index}")#>)
        {
<#
        for (var i = 1; i <= currentTo; i++) {
#>
            value<#=i#> = <#=LongOrdinal(i)#>;
<#
        }
#>
        }

        public static bool operator ==(in Variant<#=TDefinition(currentTo)#> left, in Variant<#=TDefinition(currentTo)#> right)
        {
            return left.Equals(right);
        }

        public static bool operator !=(in Variant<#=TDefinition(currentTo)#> left, in Variant<#=TDefinition(currentTo)#> right)
        {
            return !(left == right);
        }

<#
        for (var i = From; i <= currentTo; i++) {
#>
        public static explicit operator <#=T(i)#>(in Variant<#=TDefinition(currentTo)#> variant)
        {
            return variant.Get<#=LongOrdinal(i)#>();
        }

        public static implicit operator Variant<#=TDefinition(currentTo)#>(<#=T(i)#> value)
        {
            return new Variant<#=TDefinition(currentTo)#>(value);
        }

<#
        }
#>
<#
        for (var i = From; i <= currentTo - 1; i++) {
#>
        public static implicit operator Variant<#=TDefinition(currentTo)#>(in Variant<#=TDefinition(i)#> variant)
        {
            return variant._type switch
            {
<#
            for (var j = From; j <= i; j++) {
#>
                VariantType.<#=T(j)#> => new Variant<#=TDefinition(currentTo)#>(variant._value<#=j#>),
<#
            }
#>
                _ => Variant<#=TDefinition(currentTo)#>.Empty
            };
        }

<#
        }
#>
    }
<#
}
#>

}
