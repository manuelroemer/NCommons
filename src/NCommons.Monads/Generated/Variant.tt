<#
    // Recommendation:
    // Don't edit this file in Visual Studio. Download VS Code and this extension:
    // https://marketplace.visualstudio.com/items?itemName=zbecknell.t4-support
#>
<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="../CodeGen/Generics.tt" #>
<#
const int From = 1;
const int To = 8;
#>
// This code has been auto-generated by the associated .tt file.
// Any changes made to in this file will be lost when the file is regenerated.

// Performance notes:
// Each method accepting a Variant should use the "in" modifier.
// There are situations where a Variant is less than IntPtr.Size (e.g. Variant<byte>), but these
// are very uncommon. In most situations, a Variant will have AT LEAST two type parameters and
// will furthermore wrap a reference type. Therefore, the struct's size will almost always exceed
// IntPtr.Size.

namespace NCommons.Monads
{
    using System;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.Diagnostics.CodeAnalysis;
    using NCommons.Monads.Resources;

<#
    for (var currentTo = From; currentTo <= To; currentTo++) {
#>

    /// <summary>
    ///     A container which either holds a value of one of the generic type parameters or no value at all.
    ///     See remarks for details.
    /// </summary>
<#
        for (var i = From; i <= currentTo; i++) {
#>
    /// <typeparam name="<#=T(i)#>">A type which may be held by the variant.</typeparam>
<#
        }
#>
    /// 
    /// <remarks>
    ///     <h3>General Usage</h3>
    ///
    ///     In essence, the <see cref="Variant<#=TXmlDefinition(currentTo)#>"/> is a utility class which simply acts
    ///     as a data storage for one out of multiple different values. In that sense, it is very
    ///     similar to unions in other programming languages, but with the difference that a variant
    ///     may also not hold any value at all, i.e. it might be empty.
    ///     Therefore, when translating the variant's behavior into plain english, it would probably
    ///     lead to a sentence like <i>"A variant may hold one of these given values, or none at all."</i>.
    ///
    ///     The variant is ideally used for methods which need to return exactly one of multiple values.
    ///     While C# has added in-built support for tuples, they don't exactly capture the same intent
    ///     as a variant. With tuples, it may, for example, happen that two items have a value at the same
    ///     time. This is not possible with a variant.
    ///
    ///     As an example, imagine that you write a method which can return a <see cref="string"/>,
    ///     an <see cref="int"/> or no value at all. However, there is one twist - both the <see cref="string"/>
    ///     and <see cref="int"/> are allowed be <see langword="null"/>.
    ///     The first thought may be to use a tuple for encoding the return value, but then the user has a problem -
    ///     he has no way to determine which of these values was the right one. Checking them for
    ///     <see langword="null"/> is not possible, because <see langword="null"/> is a valid value for
    ///     both items:
    ///
    ///     <code>
    ///     // This returns "Hello", i.e. a string. But "null" is also a valid value for the int?.
    ///     (string?, int?) GetTwoValues() =>
    ///         ("Hello", null);
    ///     
    ///     var (s, i) = GetTwoValues();
    ///     
    ///     if (s != null)
    ///     {
    ///         Console.WriteLine("String: {0}", s);
    ///     }
    ///     else if (i != null)
    ///     {
    ///         Console.WriteLine("Int: {0}", i);
    ///     }
    ///     else
    ///     {
    ///         Console.WriteLine("The function returned neither a string nor an int.");
    ///     }
    ///     </code>
    ///
    ///     The code above seems to work fine at the first glance, but what happens, when <c>(null, null)</c>
    ///     is returned? The code will print <c>"The function returned neither a string nor an int."</c>.
    ///     This may be entirely wrong though. In fact, the function may have returned a <see cref="string"/>
    ///     which just happened to be <see langword="null"/>. As you can see, it is impossible to correctly
    ///     encode the return value using a tuple.
    ///
    ///     This problem is exactly what the variant is for:
    ///
    ///     <code>
    ///     Variant&lt;string?, int?&gt; GetTwoValues() =>
    ///         "Hello";
    ///     
    ///     var variant = GetTwoValues();
    ///     if (variant.HasValue1)
    ///     {
    ///         Console.WriteLine("String: {0}", variant.Value1);
    ///     }
    ///     else if (variant.HasValue2)
    ///     {
    ///         Console.WriteLine("Int: {0}", variant.Value2);
    ///     }
    ///     else /* if (!variant.HasValue) */
    ///     {
    ///         Console.WriteLine("The function returned neither a string nor an int.");
    ///     }
    ///     </code>
    ///
    ///     In addition to solving these problems, the variant also makes a developer's life easier
    ///     by providing multiple methods for easily accessing or switching the actual held value.
    ///     For example, the code above may be shortened to this:
    ///
    ///     <code>
    ///     Variant&lt;string?, int?&gt; GetTwoValues() =>
    ///         "Hello";
    ///     
    ///     var variant = GetTwoValues().Match(
    ///         s  => Console.WriteLine("String: {0}", s),
    ///         i  => Console.WriteLine("Int: {0}", i),
    ///         () => Console.WriteLine("The function returned neither a string nor an int.")
    ///     );
    ///     </code>
    /// 
    ///     It is also possible to use tuple-like deconstruction when interacting with variants.
    ///     In fact, any variant can be deconstructed into its set of possible values.
    ///     Note that these values are represented as <see cref="Optional{T}"/> instances, because
    ///     again, <see langword="null"/> may be a possible value for any type.
    ///     Furthermore, if the variant is empty, none of these optionals will hold a value.
    ///
    ///     <code>
    ///     Variant&lt;string?, int?&gt; GetTwoValues() =>
    ///         "Hello";
    ///     
    ///     (Optional&lt;string?&gt; s, Optional&lt;int?&gt; i) = GetTwoValues();
    ///     
    ///     if (s.HasValue)
    ///     {
    ///         Console.WriteLine("String: {0}", variant.GetValue());
    ///     }
    ///     else if (i.HasValue)
    ///     {
    ///         Console.WriteLine("Int: {0}", variant.GetValue());
    ///     }
    ///     else
    ///     {
    ///         Console.WriteLine("The function returned neither a string nor an int.");
    ///     }
    ///     </code>
    ///
    ///
    ///     <h3>Application Areas and Limitations</h3>
    ///     
    ///     The variant has been created to artifically add pseudo-support for unions to C#, because
    ///     the language is currently lacking this feature.
    ///     Due to that limited language support, the variant has a few limitations though.
    ///     For example, it is not possible to implicitly convert two variants having the same type parameters,
    ///     but in a different order, to and from each other. For example, the <c>Variant&lt;string, int&gt;</c>
    ///     and <c>Variant&lt;int, string&gt;</c> in theory represent the same set of values, but cannot
    ///     be assigned to each other.
    /// 
    ///     To minimize confusion amonst users, it is recommended to only use a variant as the return value
    ///     of a function. This means that it can immediately be deconstructed and processed and is thus
    ///     going to provide the least amount of problems.
    ///
    ///
    ///     <h3>Performance Notes</h3>
    ///     
    ///     All variant classes are value types (structs). Internally, the variants store each possible
    ///     type parameter as a separate field to avoid boxing value types. While this results in one
    ///     internal field for the <see cref="Variant{T1}"/>, the <see cref="Variant{T1, T2, T3, T4, T5, T6, T7, T8}"/>
    ///     has eight fields.
    ///     This results in a lot of data being copied when passing such a variant around.
    ///     This can be avoided by using the <see langword="in"/> modifier when using a variant as a parameter:
    ///
    ///     <code>
    ///     // Try to use the "in" modifier whenever appropriate.
    ///     public void Fn(in Variant&lt;string, int&gt; variant)
    ///     {
    ///         // ...
    ///     }
    ///     </code>
    /// </remarks>
    public readonly struct Variant<#=TDefinition(currentTo)#> : IEquatable<Variant<#=TDefinition(currentTo)#>>
    {

        internal enum VariantType : byte
        {
            Empty = 0,
<#
        for (var i = From; i <= currentTo; i++) {
#>
            <#=T(i)#> = <#=i#>,
<#
        }
#>
        }

        private static readonly Variant<#=TDefinition(currentTo)#> _empty = new Variant<#=TDefinition(currentTo)#>();
<#
        for (var i = From; i <= currentTo; i++) {
#>
        internal readonly <#=T(i)#> _value<#=i#>; 
<#
        }
#>
        internal readonly VariantType _type;

        /// <summary>
        ///     An empty <see cref="Variant<#=TXmlDefinition(currentTo)#>"/> instance which does not hold any value.
        ///     This is equivalent to an instance created via the parameterless constructor.
        /// </summary>
        /// <remarks>
        ///     Be aware that this property has a <c>ref readonly</c> return value.
        ///     In most cases, using this field instead of the parameterless constructor will be the
        ///     more performant choice.
        /// </remarks>
        public static ref readonly Variant<#=TDefinition(currentTo)#> Empty => ref _empty;

        /// <summary>
        ///     Gets a value indicating whether the variant holds a value of one of the generic type parameters.
        ///     This return <see langword="false"/> if the variant is empty, i.e. if it doesn't hold any value.
        /// </summary>
        /// <returns>
        ///     <see langword="true"/> if the variant is empty, i.e. it does not hold any value.
        ///     <see langword="false"/> if the variant holds a value of one of the generic type parameters.
        /// </returns>
        /// <remarks>
        ///     The <see cref="HasValue"/> property can be used to determine whether the variant is empty.
        ///
        ///     The following code segment demonstrates this behavior using a variant with two
        ///     type parameters:
        ///     
        ///     <code>
        ///     Variant&lt;string, int&gt; stringVariant = "Hello";
        ///     Variant&lt;string, int&gt; intVariant = 123;
        ///     Variant&lt;string, int&gt; emptyVariant = Variant&lt;string, int&gt;.Empty;
        ///
        ///     Console.WriteLine(stringVariant.HasValue);
        ///     Console.WriteLine(intVariant.HasValue);
        ///     Console.WriteLine(emptyVariant.HasValue);
        ///
        ///     // Output:
        ///     // "True"
        ///     // "True"
        ///     // "False"
        ///     </code>
        ///
        ///     The <see cref="HasValue"/> property is ideally used in conjunction with methods like
        ///     <see cref="GetValue1"/>.  You can, for example, use <see cref="HasValue"/>
        ///     to safely determine whether methods like <see cref="GetValue1"/> can be called
        ///     without leading to an exception.
        /// </remarks>
        public bool HasValue => _type != VariantType.Empty;

<#
        for (var i = From; i <= currentTo; i++) {
#>
        /// <summary>
        ///     Gets a value indicating whether the variant holds a value of type <typeparamref name="<#=T(i)#>"/>.
        /// </summary>
        /// <returns>
        ///     <see langword="true"/> if the variant holds a value of type <typeparamref name="<#=T(i)#>"/>.
        ///     <see langword="false"/> if not.
        /// </returns>
        /// <remarks>
        ///     The <see cref="HasValue<#=i#>"/> property can be used to determine whether the variant
        ///     holds a value of that type.
        ///     
        ///     The following code segment demonstrates this behavior using a variant with two
        ///     type parameters:
        ///     
        ///     <code>
        ///     Variant&lt;string, int&gt; stringVariant = "Hello";
        ///     Variant&lt;string, int&gt; intVariant = 123;
        ///     Variant&lt;string, int&gt; emptyVariant = Variant&lt;string, int&gt;.Empty;
        ///
        ///     Console.WriteLine(stringVariant.HasValue1);
        ///     Console.WriteLine(stringVariant.HasValue2);
        ///     Console.WriteLine(intVariant.HasValue1);
        ///     Console.WriteLine(intVariant.HasValue2);
        ///     Console.WriteLine(emptyVariant.HasValue1);
        ///     Console.WriteLine(emptyVariant.HasValue2);
        ///
        ///     // Output:
        ///     // "True"
        ///     // "False"
        ///     // "False"
        ///     // "True"
        ///     // "False"
        ///     // "False"
        ///     </code>
        ///
        ///     The <see cref="HasValue<#=i#>"/> property is ideally used in conjunction with methods like
        ///     <see cref="GetValue<#=i#>"/>. You can, for example, use <see cref="HasValue<#=i#>"/>
        ///     to safely determine whether <see cref="GetValue<#=i#>"/> can be called without
        ///     leading to an exception.
        /// </remarks>
        public bool HasValue<#=i#> => _type == VariantType.<#=T(i)#>;

        /// <summary>
        ///     Gets an <see cref="Optional{T}"/> which, if the variant holds a value of type
        ///     <typeparamref name="<#=T(i)#>"/>, holds the same value.
        ///     Otherwise, the optional is empty.
        /// </summary>
        /// <remarks>
        ///     The <see cref="Value<#=i#>"/> property allows you to safely access the variant's
        ///     held value of type <typeparamref name="<#=T(i)#>"/>.
        ///     In comparison to <see cref="GetValue<#=i#>"/>, this property never throws an exception
        ///     if the variant doesn't hold a value of type <typeparamref name="<#=T(i)#>"/>.
        ///     Instead, an empty <see cref="Optional{T}"/> is returned, allowing you to safely
        ///     handle both the empty and non-empty case.
        ///     
        ///     The following code segment demonstrates this behavior using a variant with two
        ///     type parameters:
        ///     
        ///     <code>
        ///     Variant&lt;string, int&gt; stringVariant = "Hello";
        ///     Variant&lt;string, int&gt; intVariant = 123;
        ///     Variant&lt;string, int&gt; emptyVariant = Variant&lt;string, int&gt;.Empty;
        ///
        ///     Console.WriteLine(stringVariant.Value1.HasValue);
        ///     Console.WriteLine(stringVariant.Value2.HasValue);
        ///     Console.WriteLine(intVariant.Value1.HasValue);
        ///     Console.WriteLine(intVariant.Value2.HasValue);
        ///     Console.WriteLine(emptyVariant.Value1.HasValue);
        ///     Console.WriteLine(emptyVariant.Value2.HasValue);
        ///
        ///     // Output:
        ///     // "True"
        ///     // "False"
        ///     // "False"
        ///     // "True"
        ///     // "False"
        ///     // "False"
        ///     </code>
        /// </remarks>
        public Optional<<#=T(i)#>> Value<#=i#> => HasValue<#=i#> ? _value<#=i#> : Optional<<#=T(i)#>>.Empty;

<#
        }
#>
        /// <summary>
        ///     Gets an <see cref="Optional{T}"/> which, if the variant holds a value of any of the
        ///     given type parameters, holds the same value.
        ///     Otherwise, the optional is empty.
        /// </summary>
        /// <remarks>
        ///     The <see cref="Value"/> property allows you to access the underlying value of the
        ///     variant if it is non-empty, independent of what exact type the variant holds.
        ///     
        ///     The following code segment demonstrates this behavior using a variant with two
        ///     type parameters:
        ///     
        ///     <code>
        ///     Variant&lt;string, int&gt; stringVariant = "Hello";
        ///     Variant&lt;string, int&gt; intVariant = 123;
        ///     Variant&lt;string, int&gt; emptyVariant = Variant&lt;string, int&gt;.Empty;
        ///
        ///     Console.WriteLine(stringVariant.HasValue);
        ///     Console.WriteLine(stringVariant.Value);
        ///     Console.WriteLine(intVariant.HasValue);
        ///     Console.WriteLine(intVariant.Value);
        ///     Console.WriteLine(emptyVariant.HasValue);
        ///     Console.WriteLine(emptyVariant.Value);
        ///     
        ///     // Output:
        ///     // "True"
        ///     // "Hello"
        ///     // "True"
        ///     // "123"
        ///     // "False"
        ///     // ""
        ///     </code>
        ///
        ///     This property can be very useful if you want to do pattern matching on a variant's
        ///     held value, or if you simply need to call a method like <c>ToString</c> on the
        ///     variant's held value.
        /// </remarks>
        public Optional<object?> Value => _type switch
        {
<#
        for (var i = From; i <= currentTo; i++) {
#>
            VariantType.<#=T(i)#> => _value<#=i#>,
<#
        }
#>
            _ => Optional<object?>.Empty
        };
        
<#
        for (var i = From; i <= currentTo; i++) {
#>
        /// <summary>
        ///     Initializes a new <see cref="Variant<#=TXmlDefinition(currentTo)#>"/> instance which
        ///     holds the specified <paramref name="value"/> of type <typeparamref name="<#=T(i)#>"/>.
        /// </summary>
        /// <param name="value">The value to be held by the variant.</param>
        public Variant(<#=T(i)#> value)
        {
            _type = VariantType.<#=T(i)#>;
            _value<#=i#> = value;
<#
        for (var j = From; j <= currentTo; j++) {
            if (i != j) {
#>
            _value<#=j#> = default!;
<#
            }
        }
#>
        }

<#
    }
#>
<#
        for (var i = From; i <= currentTo; i++) {
#>
        /// <summary>
        ///     If the variant holds a value of type <typeparamref name="<#=T(i)#>"/>, returns that value.
        ///     Otherwise an exception is thrown.
        /// </summary>
        /// <returns>
        ///     The held value of type <typeparamref name="<#=T(i)#>"/> if the variant holds such a value.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        ///     The variant doesn't hold a value of type <typeparamref name="<#=T(i)#>"/>.
        /// </exception>
        /// <remarks>
        ///     The <see cref="GetValue<#=i#>"/> function should be used if you either know or must ensure
        ///     that a variant holds a value of a specific type.
        ///     
        ///     The following code segment demonstrates this behavior using a variant with two
        ///     type parameters:
        ///     
        ///     <code>
        ///     Variant&lt;string, int&gt; stringVariant = "Hello";
        ///     Variant&lt;string, int&gt; intVariant = 123;
        ///     Variant&lt;string, int&gt; emptyVariant = Variant&lt;string, int&gt;.Empty;
        ///
        ///     Console.WriteLine(stringVariant.GetValue1());
        ///     Console.WriteLine(stringVariant.GetValue2());
        ///     Console.WriteLine(intVariant.GetValue1());
        ///     Console.WriteLine(intVariant.GetValue2());
        ///     Console.WriteLine(emptyVariant.GetValue1());
        ///     Console.WriteLine(emptyVariant.GetValue2());
        ///     
        ///     // Output:
        ///     // "Hello"
        ///     // InvalidOperationException
        ///     // InvalidOperationException
        ///     // "123"
        ///     // InvalidOperationException
        ///     // InvalidOperationException
        ///     </code>
        /// </remarks>
        public T<#=i#> GetValue<#=i#>()
        {
            if (!HasValue<#=i#>)
            {
                throw new InvalidOperationException(ExceptionStrings.Variant_GetValue_HoldsOtherType);
            }
            return _value<#=i#>;
        }

        /// <summary>
        ///     If the variant holds a value of type <typeparamref name="<#=T(i)#>"/>, returns that value.
        ///     Otherwise the default value of the type <typeparamref name="<#=T(i)#>"/> is returned.
        /// </summary>
        /// <returns>
        ///     The held value of type <typeparamref name="<#=T(i)#>"/> if the variant holds such a value.
        ///     The default value of the type <typeparamref name="<#=T(i)#>"/> otherwise.
        /// </returns>
        /// <remarks>
        ///     <see cref="GetValue<#=i#>OrDefault"/> is useful when you must retrieve a value of type
        ///     <typeparamref name="<#=T(i)#>"/>, independent of whether that is a default value or not.
        ///     
        ///     The following code segment demonstrates this behavior using a variant with two
        ///     type parameters:
        ///     
        ///     <code>
        ///     Variant&lt;string, int&gt; stringVariant = "Hello";
        ///     Variant&lt;string, int&gt; intVariant = 123;
        ///     Variant&lt;string, int&gt; emptyVariant = Variant&lt;string, int&gt;.Empty;
        ///
        ///     Console.WriteLine(stringVariant.GetValue1OrDefault());
        ///     Console.WriteLine(stringVariant.GetValue2OrDefault());
        ///     Console.WriteLine(intVariant.GetValue1OrDefault());
        ///     Console.WriteLine(intVariant.GetValue2OrDefault());
        ///     Console.WriteLine(emptyVariant.GetValue1OrDefault());
        ///     Console.WriteLine(emptyVariant.GetValue2OrDefault());
        ///     
        ///     // Output:
        ///     // "Hello"
        ///     // "0"
        ///     // "null"
        ///     // "123"
        ///     // "null"
        ///     // "0"
        ///     </code>
        /// </remarks>
        [return: MaybeNull]
        public T<#=i#> GetValue<#=i#>OrDefault()
        {
            return _value<#=i#>;
        }

        /// <summary>
        ///     If the variant holds a value of type <typeparamref name="<#=T(i)#>"/>, returns that value.
        ///     Otherwise the specified <paramref name="substitute"/> value is returned.
        /// </summary>
        /// <param name="substitute">
        ///     A value to be returned if the variant doesn't hold a value of type <typeparamref name="<#=T(i)#>"/>.
        /// </param>
        /// <returns>
        ///     The held value of type <typeparamref name="<#=T(i)#>"/> if the variant holds such a value.
        ///     <paramref name="substitute"/> otherwise.
        /// </returns>
        /// <remarks>
        ///     <see cref="GetValue<#=i#>Or(<#=T(i)#>)"/> behaves similarly to <see cref="GetValue<#=i#>OrDefault"/>,
        ///     with the exception that you can choose the result of the function if the variant
        ///     is empty.
        ///     
        ///     The following code segment demonstrates this behavior using a variant with two
        ///     type parameters:
        ///     
        ///     <code>
        ///     Variant&lt;string, int&gt; stringVariant = "Hello";
        ///     Variant&lt;string, int&gt; intVariant = 123;
        ///     Variant&lt;string, int&gt; emptyVariant = Variant&lt;string, int&gt;.Empty;
        ///
        ///     Console.WriteLine(stringVariant.GetValue1Or("Substitute"));
        ///     Console.WriteLine(stringVariant.GetValue2Or(1337));
        ///     Console.WriteLine(intVariant.GetValue1Or("Substitute"));
        ///     Console.WriteLine(intVariant.GetValue2Or(1337));
        ///     Console.WriteLine(emptyVariant.GetValue1Or("Substitute"));
        ///     Console.WriteLine(emptyVariant.GetValue2Or(1337));
        ///     
        ///     // Output:
        ///     // "Hello"
        ///     // "1337"
        ///     // "Substitute"
        ///     // "123"
        ///     // "Substitute"
        ///     // "1337"
        ///     </code>
        /// </remarks>
        public T<#=i#> GetValue<#=i#>Or(<#=T(i)#> substitute)
        {
            return HasValue<#=i#> ? _value<#=i#> : substitute;
        }

        /// <summary>
        ///     If the variant holds a value of type <typeparamref name="<#=T(i)#>"/>, returns that value.
        ///     Otherwise the value returned by the specified <paramref name="substituteProvider"/> function
        ///     is returned.
        /// </summary>
        /// <param name="substituteProvider">
        ///     A function which returns a value which is supposed to be returned
        ///     if the variant doesn't hold a value of type <typeparamref name="<#=T(i)#>"/>.
        /// </param>
        /// <returns>
        ///     The held value of type <typeparamref name="<#=T(i)#>"/> if the variant holds such a value.
        ///     A value returned by <paramref name="substituteProvider"/> otherwise.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        ///     * <paramref name="substituteProvider"/>
        /// </exception>
        /// <remarks>
        ///     <see cref="GetValue<#=i#>Or(Func{<#=T(i)#>})"/> behaves similarly to <see cref="GetValue<#=i#>OrDefault"/>,
        ///     with the exception that you can choose the result of the function if the variant
        ///     is empty.
        ///     
        ///     The following code segment demonstrates this behavior using a variant with two
        ///     type parameters:
        ///     
        ///     <code>
        ///     Variant&lt;string, int&gt; stringVariant = "Hello";
        ///     Variant&lt;string, int&gt; intVariant = 123;
        ///     Variant&lt;string, int&gt; emptyVariant = Variant&lt;string, int&gt;.Empty;
        ///
        ///     Console.WriteLine(stringVariant.GetValue1Or(() => "Substitute"));
        ///     Console.WriteLine(stringVariant.GetValue2Or(() => 1337));
        ///     Console.WriteLine(intVariant.GetValue1Or(() => "Substitute"));
        ///     Console.WriteLine(intVariant.GetValue2Or(() => 1337));
        ///     Console.WriteLine(emptyVariant.GetValue1Or(() => "Substitute"));
        ///     Console.WriteLine(emptyVariant.GetValue2Or(() => 1337));
        ///     
        ///     // Output:
        ///     // "Hello"
        ///     // "1337"
        ///     // "Substitute"
        ///     // "123"
        ///     // "Substitute"
        ///     // "1337"
        ///     </code>
        /// </remarks>
        public T<#=i#> GetValue<#=i#>Or(Func<<#=T(i)#>> substituteProvider)
        {
            _ = substituteProvider ?? throw new ArgumentNullException(nameof(substituteProvider));
            return HasValue<#=i#> ? _value<#=i#> : substituteProvider();
        }

        /// <summary>
        ///     Attempts to retrieve a value of type <typeparamref name="<#=T(i)#>"/> from the variant
        ///     and returns a value indicating whether the retrieval was successful, i.e. if the variant
        ///     actually held a value of that type.
        /// </summary>
        /// <param name="value">
        ///     A parameter which will hold the value of type <typeparamref name="<#=T(i)#>"/> if
        ///     the variant held one.
        /// </param>
        /// <returns>
        ///     <see langword="true"/> if the variant held a value of type <typeparamref name="<#=T(i)#>"/>.
        ///     <see langword="false"/> otherwise.
        /// </returns>
        public bool TryGetValue<#=i#>(out <#=T(i)#> value)
        {
            value = _value<#=i#>;
            return HasValue<#=i#>;
        }

<#
            }
#>
        /// <summary>
        ///     Executes one of the specified functions depending on which value the variant holds.
        /// </summary>
<#
        for (var i = From; i <= currentTo; i++) {
#>
        /// <param name="onValue<#=i#>">
        ///     The function to be invoked if the variant holds a value of type <typeparamref name="<#=T(i)#>"/>.
        /// </param>
<#
        }
#>
        /// <param name="onEmpty">
        ///     The function to be invoked if the variant is empty.
        /// </param>
        /// <exception cref="ArgumentNullException">
<#
        for (var i = From; i <= currentTo; i++) {
#>
        ///     * <paramref name="onValue<#=i#>"/>
<#
        }
#>
        ///     * <paramref name="onEmpty"/>
        /// </exception>
        /// <remarks>
        ///     <see cref="Match(<#=TList(currentTo, "Action{{T{0}}}")#>, Action)"/> is a utility function
        ///     which allows you to invoke one of multiple functions, depending on which value a variant
        ///     currently holds.
        ///     
        ///     The following code segment demonstrates this behavior using a variant with two
        ///     type parameters:
        ///     
        ///     <code>
        ///     static void Print(Variant&lt;string, int&gt; variant) =>
        ///         variant.Match(
        ///             str    => Console.WriteLine("string: {0}", str),
        ///             number => Console.WriteLine("int: {0}", number),
        ///             ()     => Console.WriteLine("Empty")
        ///         );
        /// 
        ///     Variant&lt;string, int&gt; stringVariant = "Hello";
        ///     Variant&lt;string, int&gt; intVariant = 123;
        ///     Variant&lt;string, int&gt; emptyVariant = Variant&lt;string, int&gt;.Empty;
        ///     
        ///     Print(stringVariant);
        ///     Print(intVariant);
        ///     Print(emptyVariant);
        ///     
        ///     // Output:
        ///     // "string: Hello"
        ///     // "int: 123"
        ///     // "Empty"
        ///     </code>
        /// </remarks>
        public void Match(<#=TList(currentTo, "Action<T{0}> onValue{0}")#>, Action onEmpty)
        {
<#
        for (var i = From; i <= currentTo; i++) {
#>
            _ = onValue<#=i#> ?? throw new ArgumentNullException(nameof(onValue<#=i#>));
<#
        }
#>
            _ = onEmpty ?? throw new ArgumentNullException(nameof(onEmpty));

            switch (_type)
            {
<#
        for (var i = From; i <= currentTo; i++) {
#>
                case VariantType.<#=T(i)#>:
                    onValue<#=i#>(_value<#=i#>);
                    break;
<#
}
#>
                default:
                    onEmpty();
                    break;
            }
        }

        /// <summary>
        ///     Executes one of the specified functions depending on which value the variant holds
        ///     and returns that function's return value.
        /// </summary>
<#
        for (var i = From; i <= currentTo; i++) {
#>
        /// <param name="onValue<#=i#>">
        ///     The function to be invoked if the variant holds a value of type <typeparamref name="<#=T(i)#>"/>.
        /// </param>
<#
        }
#>
        /// <param name="onEmpty">
        ///     The function to be invoked if the variant is empty.
        /// </param>
        /// <exception cref="ArgumentNullException">
<#
        for (var i = From; i <= currentTo; i++) {
#>
        ///     * <paramref name="onValue<#=i#>"/>
<#
        }
#>
        ///     * <paramref name="onEmpty"/>
        /// </exception>
        /// <remarks>
        ///     <see cref="Match(<#=TList(currentTo, "Action{{T{0}}}")#>, Action)"/> is a utility function
        ///     which allows you to invoke one of multiple functions, depending on which value a variant
        ///     currently holds.
        ///     
        ///     In comparison to the <see cref="Match(<#=TList(currentTo, "Action{{T{0}}}")#>, Action)"/>
        ///     overload, this method supports returning a value.
        ///     
        ///     The following code segment demonstrates this behavior using a variant with two
        ///     type parameters:
        ///     
        ///     <code>
        ///     static string Stringify(Variant&lt;string, int&gt; variant) =>
        ///         variant.Match(
        ///             str    => $"string: {str}",
        ///             number => $"int: {number}",
        ///             ()     => $"Empty"
        ///         );
        /// 
        ///     Variant&lt;string, int&gt; stringVariant = "Hello";
        ///     Variant&lt;string, int&gt; intVariant = 123;
        ///     Variant&lt;string, int&gt; emptyVariant = Variant&lt;string, int&gt;.Empty;
        ///     
        ///     Console.WriteLine(Stringify(stringVariant));
        ///     Console.WriteLine(Stringify(intVariant));
        ///     Console.WriteLine(Stringify(emptyVariant));
        ///     
        ///     // Output:
        ///     // "string: Hello"
        ///     // "int: 123"
        ///     // "Empty"
        ///     </code>
        /// </remarks>
        public TResult Match<TResult>(<#=TList(currentTo, "Func<T{0}, TResult> onValue{0}")#>, Func<TResult> onEmpty)
        {
<#
        for (var i = From; i <= currentTo; i++) {
#>
            _ = onValue<#=i#> ?? throw new ArgumentNullException(nameof(onValue<#=i#>));
<#
        }
#>
            _ = onEmpty ?? throw new ArgumentNullException(nameof(onEmpty));

            return _type switch
            {
<#
        for (var i = From; i <= currentTo; i++) {
#>
                VariantType.<#=T(i)#> => onValue<#=i#>(_value<#=i#>),
<#
}
#>
                _ => onEmpty()
            };
        }

        /// <summary>
        ///     Returns a value indicating whether the variant or its held value is equal to
        ///     the specified object.
        /// </summary>
        /// <param name="obj">
        ///     An object to be compared with the variant.
        /// </param>
        /// <returns>
        ///     <see langword="true"/> if the specified object is equal to the variant or its held value;
        ///     <see langword="false"/> if not.
        /// </returns>
        /// <remarks>
        ///     See <see cref="Equals(in Variant<#=TXmlDefinition(currentTo)#>)"/> for additional
        ///     information on how the equality comparison works.
        /// </remarks>
        /// <seealso cref="Equals(in Variant<#=TXmlDefinition(currentTo)#>)"/>
        public override bool Equals(object? obj)
        {
            return obj switch
            {
<#
        for (var i = From; i <= currentTo; i++) {
#>
                <#=T(i)#> other => Equals(other),
<#
        }
#>
                Variant<#=TDefinition(currentTo)#> other => Equals(other),
                _ => false
            };
        }

        /// <inheritdoc cref="Equals(in Variant<#=TXmlDefinition(currentTo)#>)"/>
        bool IEquatable<Variant<#=TDefinition(currentTo)#>>.Equals(Variant<#=TDefinition(currentTo)#> other)
        {
            return Equals(in other);
        }

        /// <summary>
        ///     Returns a value indicating whether the variant or its held value is equal to another variant.
        /// </summary>
        /// <param name="other">
        ///     Another <see cref="Variant<#=TXmlDefinition(currentTo)#>"/> instance to be compared with the variant.
        /// </param>
        /// <returns>
        ///     <see langword="true"/> if the two variants are equal;
        ///     <see langword="false"/> if not.
        /// </returns>
        /// <remarks>
        ///     Two variants are considered equal if:
        ///     
        ///     <list type="bullet">
        ///         <item>
        ///             <description>
        ///                 They are both empty.
        ///             </description>
        ///         </item>
        ///         <item>
        ///             <description>
        ///                 They both hold a value of the same generic type parameter and the held values
        ///                 are considered equal by a default <see cref="EqualityComparer{T}"/> instance.
        ///             </description>
        ///         </item>
        ///     </list>
        ///     
        ///     If the above conditions are not met, the two variants are considered to be unequal.
        /// </remarks>
        public bool Equals(in Variant<#=TDefinition(currentTo)#> other)
        {
            if (_type != other._type)
            {
                return false;
            }

            // The two variants hold a value of the same type at this point.
            if (!HasValue)
            {
                return true;
            }

            return _type switch
            {
<#
        for (var i = 1; i <= currentTo; i++) {
#>
                VariantType.<#=T(i)#> => EqualityComparer<<#=T(i)#>>.Default.Equals(_value<#=i#>, other._value<#=i#>),
<#
        }
#>
                _ => false
            };
        }

        /// <summary>
        ///     Returns a unique hash code for the current instance.
        /// </summary>
        /// <returns>
        ///     <list type="bullet">
        ///         <item>
        ///             <description>
        ///                 <c>-1</c> if the variant is empty.
        ///             </description>
        ///         </item>
        ///         <item>
        ///             <description>
        ///                 <c>0</c> if the variant holds a value which is <see langword="null"/>.
        ///             </description>
        ///         </item>
        ///         <item>
        ///             <description>
        ///                 The hash code of the held value if it is not <see langword="null"/>.
        ///             </description>
        ///         </item>
        ///     </list>
        /// </returns>
        public override int GetHashCode()
        {
            return _type switch
            {
<#
        for (var i = 1; i <= currentTo; i++) {
#>
                VariantType.<#=T(i)#> => _value<#=i#>?.GetHashCode() ?? 0,
<#
        }
#>
                _ => -1
            };
        }

        /// <summary>
        ///     Returns a string representation of the variant or its held value.
        /// </summary>
        /// <returns>
        ///     An empty string if the variant is either empty or its held value is <see langword="null"/>.
        ///     Otherwise, returns the value of calling <see cref="object.ToString"/> on the
        ///     held value.
        /// </returns>
        public override string? ToString()
        {
            return _type switch
            {
<#
        for (var i = 1; i <= currentTo; i++) {
#>
                VariantType.<#=T(i)#> => _value<#=i#> is null ? string.Empty : _value<#=i#>.ToString(),
<#
        }
#>
                _ => string.Empty
            };
        }
        
<#
        if (currentTo == 1) {
#>
        /// <summary>
        ///     Returns a new <see cref="Optional{T}"/> which represents the same state as the variant,
        ///     i.e. it holds a value if the variant holds a value or it is empty if the variant is empty.
        /// </summary>
        /// <returns>
        ///     A new <see cref="Optional{T}"/> holding the variant's value if it holds one.
        ///     An empty <see cref="Optional{T}"/> if the variant is empty.
        /// </returns>
        /// <remarks>
        ///     The <see cref="Variant{T1}"/> essentially has the same functionality as an <see cref="Optional{T}"/>.
        ///     Both types either hold a value or are empty. Therefore, any <see cref="Optional{T}"/> can
        ///     easily be converted to a <see cref="Variant{T1}"/> and vice versa.
        ///     
        ///     Nevertheless, the two types serve different purposes. While an <see cref="Optional{T}"/> is mainly
        ///     designed for modeling the absence of a value, the variant family is designed for scenarios where
        ///     one needs to accept or provide an instance of one or many types, or none.
        ///     Depending on the use case, you may pick either type for your scenario. If you ever
        ///     need to switch between the two, you can use one of the available conversion methods.
        /// </remarks>
        public Optional<T1> ToOptional()
        {
            return HasValue1 ? new Optional<T1>(_value1) : Optional<T1>.Empty; 
        }

<#
        }
#>
        /// <summary>
        ///     Deconstructs the variant into its set of possible values, represented as
        ///     <see cref="Optional{T}"/> instances.
        /// </summary>
<#
        for (var i = From; i <= currentTo; i++) {
#>
        /// <param name="value<#=i#>">A parameter holding the value of type <typeparamref name="<#=T(i)#>"/> after the deconstruction.</param>
<#
        }
#>
        /// <remarks>
        ///     Deconstructing a variant returns the same result as accessing properties like <see cref="Value1"/>.
        ///     Nontheless, it can be incredibly useful to give context to the values which a variant holds,
        ///     because the variant's possible values can be named during deconstruction. This can make a huge
        ///     difference when trying to understand code.
        ///     For example, <c>Transfer(variant.GetValue1())</c> is much harder to understand than:
        ///     
        ///     <code>
        ///     (Optional&lt;double&gt; bankAccountBalance, _) = variant;
        ///     Transfer(bankAccountBalance.GetValue());
        ///     </code>
        /// </remarks>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public void Deconstruct(<#=TParameters(currentTo, index => $"out Optional<{T(index)}> value{index}")#>)
        {
<#
        for (var i = 1; i <= currentTo; i++) {
#>
            value<#=i#> = Value<#=i#>;
<#
        }
#>
        }

        /// <summary>
        ///     Returns a value indicating whether the two variant instances are equal.
        ///     See <see cref="Equals(in Variant<#=TXmlDefinition(currentTo)#>)"/> for additional information how the
        ///     equality comparison works.
        /// </summary>
        /// <param name="left">The first variant instance.</param>
        /// <param name="right">The second variant instance.</param>
        /// <returns>
        ///     <see langword="true"/> if the two variant instances are equal;
        ///     <see langword="false"/> if not.
        /// </returns>
        /// <seealso cref="Equals(in Variant<#=TXmlDefinition(currentTo)#>)"/>
        public static bool operator ==(in Variant<#=TDefinition(currentTo)#> left, in Variant<#=TDefinition(currentTo)#> right)
        {
            return left.Equals(right);
        }

        /// <summary>
        ///     Returns a value indicating whether the two variant instances are unequal.
        ///     See <see cref="Equals(in Variant<#=TXmlDefinition(currentTo)#>)"/> for additional information how the
        ///     equality comparison works.
        /// </summary>
        /// <param name="left">The first variant instance.</param>
        /// <param name="right">The second variant instance.</param>
        /// <returns>
        ///     <see langword="true"/> if the two variant instances are unequal;
        ///     <see langword="false"/> if not.
        /// </returns>
        /// <seealso cref="Equals(in Variant<#=TXmlDefinition(currentTo)#>)"/>
        public static bool operator !=(in Variant<#=TDefinition(currentTo)#> left, in Variant<#=TDefinition(currentTo)#> right)
        {
            return !(left == right);
        }

<#
        for (var i = From; i <= currentTo; i++) {
#>
        /// <summary>
        ///     Returns a new <see cref="Variant<#=TXmlDefinition(currentTo)#>"/> instance which holds the
        ///     specified <paramref name="value"/>.
        /// </summary>
        /// <param name="value">The value to be held by the variant.</param>
        public static implicit operator Variant<#=TDefinition(currentTo)#>(<#=T(i)#> value)
        {
            return new Variant<#=TDefinition(currentTo)#>(value);
        }

        /// <summary>
        ///     If the variant holds a value of type <typeparamref name="<#=T(i)#>"/>, returns that value.
        ///     Otherwise an exception is thrown.
        /// </summary>
        /// <returns>
        ///     The held value of type <typeparamref name="<#=T(i)#>"/> if the variant holds such a value.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        ///     The variant doesn't hold a value of type <typeparamref name="<#=T(i)#>"/>.
        /// </exception>
        /// <seealso cref="GetValue<#=i#>"/>
        public static explicit operator <#=T(i)#>(in Variant<#=TDefinition(currentTo)#> variant)
        {
            return variant.GetValue<#=i#>();
        }

<#
        }
#>
    }
<#
}
#>

}
