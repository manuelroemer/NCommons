<#
    // Recommendation:
    // Don't edit this file in Visual Studio. Download VS Code and this extension:
    // https://marketplace.visualstudio.com/items?itemName=zbecknell.t4-support
#>
<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file=".\..\CodeGen\Generics.tt" #>
<#@ include file=".\..\CodeGen\Ordinals.tt" #>
<#
const int From = 1;
const int To = 8;
#>
// This code has been auto-generated by the associated .tt file.
// Any changes made to in this file will be lost when the file is regenerated.

// Performance notes:
// Each method accepting a Variant should use the "in" modifier.
// There are situations where a Variant is less than IntPtr.Size (e.g. Variant<byte>), but these
// are very uncommon. In most situations, a Variant will have AT LEAST two type parameters and
// will furthermore wrap a reference type. Therefore, the struct's size will almost always exceed
// IntPtr.Size.

namespace NCommons.Monads
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.Diagnostics.CodeAnalysis;
    using NCommons.Monads.Resources;

<#
    for (var currentTo = From; currentTo <= To; currentTo++) {
#>

    public readonly struct Variant<#=TDefinition(currentTo)#> : IEquatable<Variant<#=TDefinition(currentTo)#>>
    {

        internal enum VariantType : byte
        {
            Empty = 0,
<#
        for (var i = From; i <= currentTo; i++) {
#>
            <#=T(i)#> = <#=i#>,
<#
        }
#>
        }

        private static readonly Variant<#=TDefinition(currentTo)#> _empty = new Variant<#=TDefinition(currentTo)#>();
<#
        for (var i = From; i <= currentTo; i++) {
#>
        internal readonly <#=T(i)#> _value<#=i#>; 
<#
        }
#>
        internal readonly VariantType _type;

        /// <summary>
        ///     An empty <see cref="Variant<#=TXmlDefinition(currentTo)#>"/> instance which does not hold any value.
        ///     This is equivalent to an instance created via the parameterless constructor.
        /// </summary>
        /// <remarks>
        ///     Be aware that this property has a <c>ref readonly</c> return value.
        ///     In most cases, using this field instead of the parameterless constructor will be the
        ///     more performant choice.
        /// </remarks>
        public static ref readonly Variant<#=TDefinition(currentTo)#> Empty => ref _empty;

        /// <summary>
        ///     Gets a value indicating whether the variant is empty, i.e. if it does not hold any value.
        /// </summary>
        /// <returns>
        ///     <see langword="true"/> if the optional is empty, i.e. it does not hold any value.
        ///     <see langword="false"/> if the optional holds a value of one of the generic type parameters.
        /// </returns>
        /// <remarks>
        ///     The <see cref="IsEmpty"/> property can be used to determine whether the variant is empty.
        ///
        ///     The following code segment demonstrates this behavior using a variant with two
        ///     type parameters:
        ///     
        ///     <code>
        ///     Variant&lt;string, int&gt; stringVariant = "Hello";
        ///     Variant&lt;string, int&gt; intVariant = 123;
        ///     Variant&lt;string, int&gt; emptyVariant = Variant&lt;string, int&gt;.Empty;
        ///
        ///     Console.WriteLine(stringVariant.IsEmpty);
        ///     Console.WriteLine(intVariant.IsEmpty);
        ///     Console.WriteLine(emptyVariant.IsEmpty);
        ///
        ///     // Output:
        ///     // "False"
        ///     // "False"
        ///     // "True"
        ///     </code>
        ///
        ///     The <see cref="IsEmpty"/> property is ideally used in conjunction with methods like
        ///     <see cref="GetValue1"/>.  You can, for example, use <see cref="IsEmpty"/>
        ///     to safely determine whether methods like <see cref="GetValue1"/> can be called
        ///     without leading to an exception.
        /// </remarks>
        public bool IsEmpty => _type == VariantType.Empty;

<#
        for (var i = From; i <= currentTo; i++) {
#>
        /// <summary>
        ///     Gets a value indicating whether the variant holds a value of type <typeparamref name="<#=T(i)#>"/>.
        /// </summary>
        /// <returns>
        ///     <see langword="true"/> if the variant holds a value of type <typeparamref name="<#=T(i)#>"/>.
        ///     <see langword="false"/> if not.
        /// </returns>
        /// <remarks>
        ///     The <see cref="IsValue<#=i#>"/> property can be used to determine whether the variant
        ///     holds a value of that type.
        ///     
        ///     The following code segment demonstrates this behavior using a variant with two
        ///     type parameters:
        ///     
        ///     <code>
        ///     Variant&lt;string, int&gt; stringVariant = "Hello";
        ///     Variant&lt;string, int&gt; intVariant = 123;
        ///     Variant&lt;string, int&gt; emptyVariant = Variant&lt;string, int&gt;.Empty;
        ///
        ///     Console.WriteLine(stringVariant.IsValue1);
        ///     Console.WriteLine(stringVariant.IsValue2);
        ///     Console.WriteLine(intVariant.IsValue1);
        ///     Console.WriteLine(intVariant.IsValue2);
        ///     Console.WriteLine(emptyVariant.IsValue1);
        ///     Console.WriteLine(emptyVariant.IsValue2);
        ///
        ///     // Output:
        ///     // "True"
        ///     // "False"
        ///     // "False"
        ///     // "True"
        ///     // "False"
        ///     // "False"
        ///     </code>
        ///
        ///     The <see cref="IsValue<#=i#>"/> property is ideally used in conjunction with methods like
        ///     <see cref="GetValue<#=i#>"/>. You can, for example, use <see cref="IsValue<#=i#>"/>
        ///     to safely determine whether <see cref="GetValue<#=i#>"/> can be called without
        ///     leading to an exception.
        /// </remarks>
        public bool IsValue<#=i#> => _type == VariantType.<#=T(i)#>;

        /// <summary>
        ///     Gets an <see cref="Optional{T}"/> which, if the variant holds a value of type
        ///     <typeparamref name="<#=T(i)#>"/>, holds the same value.
        ///     Otherwise, the optional is empty.
        /// </summary>
        /// <remarks>
        ///     The <see cref="Value<#=i#>"/> property allows you to safely access the variant's
        ///     held value of type <typeparamref name="<#=T(i)#>"/>.
        ///     In comparison to <see cref="GetValue<#=i#>"/>, this property never throws an exception
        ///     if the variant doesn't hold a value of type <typeparamref name="<#=T(i)#>"/>.
        ///     Instead, an empty <see cref="Optional{T}"/> is returned, allowing you to safely
        ///     handle both the empty and non-empty case.
        ///     
        ///     The following code segment demonstrates this behavior using a variant with two
        ///     type parameters:
        ///     
        ///     <code>
        ///     Variant&lt;string, int&gt; stringVariant = "Hello";
        ///     Variant&lt;string, int&gt; intVariant = 123;
        ///     Variant&lt;string, int&gt; emptyVariant = Variant&lt;string, int&gt;.Empty;
        ///
        ///     Console.WriteLine(stringVariant.Value1.HasValue);
        ///     Console.WriteLine(stringVariant.Value2.HasValue);
        ///     Console.WriteLine(intVariant.Value1.HasValue);
        ///     Console.WriteLine(intVariant.Value2.HasValue);
        ///     Console.WriteLine(emptyVariant.Value1.HasValue);
        ///     Console.WriteLine(emptyVariant.Value2.HasValue);
        ///
        ///     // Output:
        ///     // "True"
        ///     // "False"
        ///     // "False"
        ///     // "True"
        ///     // "False"
        ///     // "False"
        ///     </code>
        /// </remarks>
        public Optional<<#=T(i)#>> Value<#=i#> => IsValue<#=i#> ? _value<#=i#> : Optional<<#=T(i)#>>.Empty;

<#
        }
#>
        /// <summary>
        ///     Gets an <see cref="Optional{T}"/> which, if the variant holds a value of any of the
        ///     given type parameters, holds the same value.
        ///     Otherwise, the optional is empty.
        /// </summary>
        /// <remarks>
        ///     The <see cref="Value"/> property allows you to access the underlying value of the
        ///     variant if it is non-empty, independent of what exact type the variant holds.
        ///     
        ///     The following code segment demonstrates this behavior using a variant with two
        ///     type parameters:
        ///     
        ///     <code>
        ///     Variant&lt;string, int&gt; stringVariant = "Hello";
        ///     Variant&lt;string, int&gt; intVariant = 123;
        ///     Variant&lt;string, int&gt; emptyVariant = Variant&lt;string, int&gt;.Empty;
        ///
        ///     Console.WriteLine(stringVariant.HasValue);
        ///     Console.WriteLine(stringVariant.Value);
        ///     Console.WriteLine(intVariant.HasValue);
        ///     Console.WriteLine(intVariant.Value);
        ///     Console.WriteLine(emptyVariant.HasValue);
        ///     Console.WriteLine(emptyVariant.Value);
        ///     
        ///     // Output:
        ///     // "True"
        ///     // "Hello"
        ///     // "True"
        ///     // "123"
        ///     // "False"
        ///     // ""
        ///     </code>
        ///
        ///     This property can be very useful if you want to do pattern matching on a variant's
        ///     held value, or if you simply need to call a method like <c>ToString</c> on the
        ///     variant's held value.
        /// </remarks>
        public Optional<object?> Value => _type switch
        {
<#
        for (var i = From; i <= currentTo; i++) {
#>
            VariantType.<#=T(i)#> => _value<#=i#>,
<#
        }
#>
            _ => Optional<object?>.Empty
        };
        
<#
        for (var i = From; i <= currentTo; i++) {
#>
        /// <summary>
        ///     Initializes a new <see cref="Variant<#=TXmlDefinition(currentTo)#>"/> instance which
        ///     holds the specified <paramref name="value"/> of type <typeparamref name="<#=T(i)#>"/>.
        /// </summary>
        /// <param name="value">The value to be held by the variant.</param>
        public Variant(<#=T(i)#> value)
        {
            _type = VariantType.<#=T(i)#>;
            _value<#=i#> = value;
<#
        for (var j = From; j <= currentTo; j++) {
            if (i != j) {
#>
            _value<#=j#> = default!;
<#
            }
        }
#>
        }

<#
    }
#>
<#
        for (var i = From; i <= currentTo; i++) {
#>
        /// <summary>
        ///     If the variant holds a value of type <typeparamref name="<#=T(i)#>"/>, returns that value.
        ///     Otherwise an exception is thrown.
        /// </summary>
        /// <returns>
        ///     The held value of type <typeparamref name="<#=T(i)#>"/> if the variant holds such a value.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        ///     The variant doesn't hold a value of type <typeparamref name="<#=T(i)#>"/>.
        /// </exception>
        /// <remarks>
        ///     The <see cref="GetValue<#=i#>"/> function should be used if you either know or must ensure
        ///     that a variant holds a value of a specific type.
        ///     
        ///     The following code segment demonstrates this behavior using a variant with two
        ///     type parameters:
        ///     
        ///     <code>
        ///     Variant&lt;string, int&gt; stringVariant = "Hello";
        ///     Variant&lt;string, int&gt; intVariant = 123;
        ///     Variant&lt;string, int&gt; emptyVariant = Variant&lt;string, int&gt;.Empty;
        ///
        ///     Console.WriteLine(stringVariant.GetValue1());
        ///     Console.WriteLine(stringVariant.GetValue2());
        ///     Console.WriteLine(intVariant.GetValue1());
        ///     Console.WriteLine(intVariant.GetValue2());
        ///     Console.WriteLine(emptyVariant.GetValue1());
        ///     Console.WriteLine(emptyVariant.GetValue2());
        ///     
        ///     // Output:
        ///     // "Hello"
        ///     // InvalidOperationException
        ///     // InvalidOperationException
        ///     // "123"
        ///     // InvalidOperationException
        ///     // InvalidOperationException
        ///     </code>
        /// </remarks>
        public T<#=i#> GetValue<#=i#>()
        {
            if (!IsValue<#=i#>)
            {
                throw new InvalidOperationException(ExceptionStrings.Variant_GetValue_HoldsOtherType);
            }
            return _value<#=i#>;
        }

        /// <summary>
        ///     If the variant holds a value of type <typeparamref name="<#=T(i)#>"/>, returns that value.
        ///     Otherwise the default value of the type <typeparamref name="<#=T(i)#>"/> is returned.
        /// </summary>
        /// <returns>
        ///     The held value of type <typeparamref name="<#=T(i)#>"/> if the variant holds such a value.
        ///     The default value of the type <typeparamref name="<#=T(i)#>"/> otherwise.
        /// </returns>
        /// <remarks>
        ///     <see cref="GetValue<#=i#>OrDefault"/> is useful when you must retrieve a value of type
        ///     <typeparamref name="<#=T(i)#>"/>, independent of whether that is a default value or not.
        ///     
        ///     The following code segment demonstrates this behavior using a variant with two
        ///     type parameters:
        ///     
        ///     <code>
        ///     Variant&lt;string, int&gt; stringVariant = "Hello";
        ///     Variant&lt;string, int&gt; intVariant = 123;
        ///     Variant&lt;string, int&gt; emptyVariant = Variant&lt;string, int&gt;.Empty;
        ///
        ///     Console.WriteLine(stringVariant.GetValue1OrDefault());
        ///     Console.WriteLine(stringVariant.GetValue2OrDefault());
        ///     Console.WriteLine(intVariant.GetValue1OrDefault());
        ///     Console.WriteLine(intVariant.GetValue2OrDefault());
        ///     Console.WriteLine(emptyVariant.GetValue1OrDefault());
        ///     Console.WriteLine(emptyVariant.GetValue2OrDefault());
        ///     
        ///     // Output:
        ///     // "Hello"
        ///     // "0"
        ///     // "null"
        ///     // "123"
        ///     // "null"
        ///     // "0"
        ///     </code>
        /// </remarks>
        [return: MaybeNull]
        public T<#=i#> GetValue<#=i#>OrDefault()
        {
            return _value<#=i#>;
        }

        /// <summary>
        ///     If the variant holds a value of type <typeparamref name="<#=T(i)#>"/>, returns that value.
        ///     Otherwise the specified <paramref name="substitute"/> value is returned.
        /// </summary>
        /// <param name="substitute">
        ///     A value to be returned if the variant doesn't hold a value of type <typeparamref name="<#=T(i)#>"/>.
        /// </param>
        /// <returns>
        ///     The held value of type <typeparamref name="<#=T(i)#>"/> if the variant holds such a value.
        ///     <paramref name="substitute"/> otherwise.
        /// </returns>
        /// <remarks>
        ///     <see cref="GetValue<#=i#>Or(<#=T(i)#>)"/> behaves similarly to <see cref="GetValue<#=i#>OrDefault"/>,
        ///     with the exception that you can choose the result of the function if the optional
        ///     is empty.
        ///     
        ///     The following code segment demonstrates this behavior using a variant with two
        ///     type parameters:
        ///     
        ///     <code>
        ///     Variant&lt;string, int&gt; stringVariant = "Hello";
        ///     Variant&lt;string, int&gt; intVariant = 123;
        ///     Variant&lt;string, int&gt; emptyVariant = Variant&lt;string, int&gt;.Empty;
        ///
        ///     Console.WriteLine(stringVariant.GetValue1Or("Substitute"));
        ///     Console.WriteLine(stringVariant.GetValue2Or(1337));
        ///     Console.WriteLine(intVariant.GetValue1Or("Substitute"));
        ///     Console.WriteLine(intVariant.GetValue2Or(1337));
        ///     Console.WriteLine(emptyVariant.GetValue1Or("Substitute"));
        ///     Console.WriteLine(emptyVariant.GetValue2Or(1337));
        ///     
        ///     // Output:
        ///     // "Hello"
        ///     // "1337"
        ///     // "Substitute"
        ///     // "123"
        ///     // "Substitute"
        ///     // "1337"
        ///     </code>
        /// </remarks>
        public T<#=i#> GetValue<#=i#>Or(<#=T(i)#> substitute)
        {
            return IsValue<#=i#> ? _value<#=i#> : substitute;
        }

        /// <summary>
        ///     If the variant holds a value of type <typeparamref name="<#=T(i)#>"/>, returns that value.
        ///     Otherwise the value returned by the specified <paramref name="substituteProvider"/> function
        ///     is returned.
        /// </summary>
        /// <param name="substituteProvider">
        ///     A function which returns a value which is supposed to be returned
        ///     if the variant doesn't hold a value of type <typeparamref name="<#=T(i)#>"/>.
        /// </param>
        /// <returns>
        ///     The held value of type <typeparamref name="<#=T(i)#>"/> if the variant holds such a value.
        ///     A value returned by <paramref name="substituteProvider"/> otherwise.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        ///     * <paramref name="substituteProvider"/>
        /// </exception>
        /// <remarks>
        ///     <see cref="GetValue<#=i#>Or(Func{<#=T(i)#>})"/> behaves similarly to <see cref="GetValue<#=i#>OrDefault"/>,
        ///     with the exception that you can choose the result of the function if the optional
        ///     is empty.
        ///     
        ///     The following code segment demonstrates this behavior using a variant with two
        ///     type parameters:
        ///     
        ///     <code>
        ///     Variant&lt;string, int&gt; stringVariant = "Hello";
        ///     Variant&lt;string, int&gt; intVariant = 123;
        ///     Variant&lt;string, int&gt; emptyVariant = Variant&lt;string, int&gt;.Empty;
        ///
        ///     Console.WriteLine(stringVariant.GetValue1Or(() => "Substitute"));
        ///     Console.WriteLine(stringVariant.GetValue2Or(() => 1337));
        ///     Console.WriteLine(intVariant.GetValue1Or(() => "Substitute"));
        ///     Console.WriteLine(intVariant.GetValue2Or(() => 1337));
        ///     Console.WriteLine(emptyVariant.GetValue1Or(() => "Substitute"));
        ///     Console.WriteLine(emptyVariant.GetValue2Or(() => 1337));
        ///     
        ///     // Output:
        ///     // "Hello"
        ///     // "1337"
        ///     // "Substitute"
        ///     // "123"
        ///     // "Substitute"
        ///     // "1337"
        ///     </code>
        /// </remarks>
        public T<#=i#> GetValue<#=i#>Or(Func<<#=T(i)#>> substituteProvider)
        {
            _ = substituteProvider ?? throw new ArgumentNullException(nameof(substituteProvider));
            return IsValue<#=i#> ? _value<#=i#> : substituteProvider();
        }

        /// <summary>
        ///     Attempts to retrieve a value of type <typeparamref name="<#=T(i)#>"/> from the variant
        ///     and returns a value indicating whether the retrieval was successful, i.e. if the variant
        ///     actually held a value of that type.
        /// </summary>
        /// <param name="value">
        ///     A parameter which will hold the value of type <typeparamref name="<#=T(i)#>"/> if
        ///     the variant held one.
        /// </param>
        /// <returns>
        ///     <see langword="true"/> if the variant held a value of type <typeparamref name="<#=T(i)#>"/>.
        ///     <see langword="false"/> otherwise.
        /// </returns>
        public bool TryGetValue<#=i#>(out <#=T(i)#> value)
        {
            value = _value<#=i#>;
            return IsValue<#=i#>;
        }

<#
            }
#>
        /// <summary>
        ///     Executes one of the specified functions depending on which value the variant holds.
        /// </summary>
<#
        for (var i = From; i <= currentTo; i++) {
#>
        /// <param name="onValue<#=i#>">
        ///     The function to be invoked if the variant holds a value of type <typeparamref name="<#=T(i)#>"/>.
        /// </param>
<#
        }
#>
        /// <param name="onEmpty">
        ///     The function to be invoked if the variant is empty.
        /// </param>
        /// <exception cref="ArgumentNullException">
<#
        for (var i = From; i <= currentTo; i++) {
#>
        ///     * <paramref name="onValue<#=i#>"/>
<#
        }
#>
        ///     * <paramref name="onEmpty"/>
        /// </exception>
        /// <remarks>
        ///     <see cref="Match(<#=TList(currentTo, "Action{{T{0}}}")#>, Action)"/> is a utility function
        ///     which allows you to invoke one of multiple functions, depending on which value a variant
        ///     currently holds.
        ///     
        ///     The following code segment demonstrates this behavior using a variant with two
        ///     type parameters:
        ///     
        ///     <code>
        ///     static void Print(Variant&lt;string, int&gt; variant) =>
        ///         variant.Match(
        ///             str    => Console.WriteLine("string: {0}", str),
        ///             number => Console.WriteLine("int: {0}", number),
        ///             ()     => Console.WriteLine("Empty")
        ///         );
        /// 
        ///     Variant&lt;string, int&gt; stringVariant = "Hello";
        ///     Variant&lt;string, int&gt; intVariant = 123;
        ///     Variant&lt;string, int&gt; emptyVariant = Variant&lt;string, int&gt;.Empty;
        ///     
        ///     Print(stringVariant);
        ///     Print(intVariant);
        ///     Print(emptyVariant);
        ///     
        ///     // Output:
        ///     // "string: Hello"
        ///     // "int: 123"
        ///     // "Empty"
        ///     </code>
        /// </remarks>
        public void Match(<#=TList(currentTo, "Action<T{0}> onValue{0}")#>, Action onEmpty)
        {
<#
        for (var i = From; i <= currentTo; i++) {
#>
            _ = onValue<#=i#> ?? throw new ArgumentNullException(nameof(onValue<#=i#>));
<#
        }
#>
            _ = onEmpty ?? throw new ArgumentNullException(nameof(onEmpty));

            switch (_type)
            {
<#
        for (var i = From; i <= currentTo; i++) {
#>
                case VariantType.<#=T(i)#>:
                    onValue<#=i#>(_value<#=i#>);
                    break;
<#
}
#>
                default:
                    onEmpty();
                    break;
            }
        }

        /// <summary>
        ///     Executes one of the specified functions depending on which value the variant holds
        ///     and returns that function's return value.
        /// </summary>
<#
        for (var i = From; i <= currentTo; i++) {
#>
        /// <param name="onValue<#=i#>">
        ///     The function to be invoked if the variant holds a value of type <typeparamref name="<#=T(i)#>"/>.
        /// </param>
<#
        }
#>
        /// <param name="onEmpty">
        ///     The function to be invoked if the variant is empty.
        /// </param>
        /// <exception cref="ArgumentNullException">
<#
        for (var i = From; i <= currentTo; i++) {
#>
        ///     * <paramref name="onValue<#=i#>"/>
<#
        }
#>
        ///     * <paramref name="onEmpty"/>
        /// </exception>
        /// <remarks>
        ///     <see cref="Match(<#=TList(currentTo, "Action{{T{0}}}")#>, Action)"/> is a utility function
        ///     which allows you to invoke one of multiple functions, depending on which value a variant
        ///     currently holds.
        ///     
        ///     In comparison to the <see cref="Match(<#=TList(currentTo, "Action{{T{0}}}")#>, Action)"/>
        ///     overload, this method supports returning a value.
        ///     
        ///     The following code segment demonstrates this behavior using a variant with two
        ///     type parameters:
        ///     
        ///     <code>
        ///     static string Stringify(Variant&lt;string, int&gt; variant) =>
        ///         variant.Match(
        ///             str    => $"string: {str}",
        ///             number => $"int: {number}",
        ///             ()     => $"Empty"
        ///         );
        /// 
        ///     Variant&lt;string, int&gt; stringVariant = "Hello";
        ///     Variant&lt;string, int&gt; intVariant = 123;
        ///     Variant&lt;string, int&gt; emptyVariant = Variant&lt;string, int&gt;.Empty;
        ///     
        ///     Console.WriteLine(Stringify(stringVariant));
        ///     Console.WriteLine(Stringify(intVariant));
        ///     Console.WriteLine(Stringify(emptyVariant));
        ///     
        ///     // Output:
        ///     // "string: Hello"
        ///     // "int: 123"
        ///     // "Empty"
        ///     </code>
        /// </remarks>
        public TResult Match<TResult>(<#=TList(currentTo, "Func<T{0}, TResult> onValue{0}")#>, Func<TResult> onEmpty)
        {
<#
        for (var i = From; i <= currentTo; i++) {
#>
            _ = onValue<#=i#> ?? throw new ArgumentNullException(nameof(onValue<#=i#>));
<#
        }
#>
            _ = onEmpty ?? throw new ArgumentNullException(nameof(onEmpty));

            return _type switch
            {
<#
        for (var i = From; i <= currentTo; i++) {
#>
                VariantType.<#=T(i)#> => onValue<#=i#>(_value<#=i#>),
<#
}
#>
                _ => onEmpty()
            };
        }

        /// <summary>
        ///     Returns a value indicating whether the variant or its held value is equal to
        ///     the specified object.
        /// </summary>
        /// <param name="obj">
        ///     An object to be compared with the variant.
        /// </param>
        /// <returns>
        ///     <see langword="true"/> if the specified object is equal to the variant or its held value;
        ///     <see langword="false"/> if not.
        /// </returns>
        /// <remarks>
        ///     See <see cref="Equals(in Variant<#=TXmlDefinition(currentTo)#>)"/> for additional
        ///     information on how the equality comparison works.
        /// </remarks>
        /// <seealso cref="Equals(in Variant<#=TXmlDefinition(currentTo)#>)"/>
        public override bool Equals(object? obj)
        {
            return obj switch
            {
<#
        for (var i = From; i <= currentTo; i++) {
#>
                <#=T(i)#> other => Equals(other),
<#
        }
#>
                Variant<#=TDefinition(currentTo)#> other => Equals(other),
                _ => false
            };
        }

        /// <inheritdoc cref="Equals(in Variant<#=TXmlDefinition(currentTo)#>)"/>
        bool IEquatable<Variant<#=TDefinition(currentTo)#>>.Equals(Variant<#=TDefinition(currentTo)#> other)
        {
            return Equals(in other);
        }

        /// <summary>
        ///     Returns a value indicating whether the variant or its held value is equal to another variant.
        /// </summary>
        /// <param name="other">
        ///     Another <see cref="Variant<#=TXmlDefinition(currentTo)#>"/> instance to be compared with the variant.
        /// </param>
        /// <returns>
        ///     <see langword="true"/> if the two variants are equal;
        ///     <see langword="false"/> if not.
        /// </returns>
        /// <remarks>
        ///     Two variants are considered equal if:
        ///     
        ///     <list type="bullet">
        ///         <item>
        ///             <description>
        ///                 They are both empty.
        ///             </description>
        ///         </item>
        ///         <item>
        ///             <description>
        ///                 They both hold a value of the same generic type parameter and the held values
        ///                 are considered equal by a default <see cref="EqualityComparer{T}"/> instance.
        ///             </description>
        ///         </item>
        ///     </list>
        ///     
        ///     If the above conditions are not met, the two variants are considered to be unequal.
        /// </remarks>
        public bool Equals(in Variant<#=TDefinition(currentTo)#> other)
        {
            if (_type != other._type)
            {
                return false;
            }

            // The two variants hold a value of the same type at this point.
            if (IsEmpty)
            {
                return true;
            }

            return _type switch
            {
<#
        for (var i = 1; i <= currentTo; i++) {
#>
                VariantType.<#=T(i)#> => EqualityComparer<<#=T(i)#>>.Default.Equals(_value<#=i#>, other._value<#=i#>),
<#
        }
#>
                _ => false
            };
        }

        /// <summary>
        ///     Returns a unique hash code for the current instance.
        /// </summary>
        /// <returns>
        ///     <list type="bullet">
        ///         <item>
        ///             <description>
        ///                 <c>-1</c> if the variant is empty.
        ///             </description>
        ///         </item>
        ///         <item>
        ///             <description>
        ///                 <c>0</c> if the variant holds a value which is <see langword="null"/>.
        ///             </description>
        ///         </item>
        ///         <item>
        ///             <description>
        ///                 The hash code of the held value if it is not <see langword="null"/>.
        ///             </description>
        ///         </item>
        ///     </list>
        /// </returns>
        public override int GetHashCode()
        {
            return _type switch
            {
<#
        for (var i = 1; i <= currentTo; i++) {
#>
                VariantType.<#=T(i)#> => _value<#=i#>?.GetHashCode() ?? 0,
<#
        }
#>
                _ => -1
            };
        }

        /// <summary>
        ///     Returns a string representation of the variant or its held value.
        /// </summary>
        /// <returns>
        ///     An empty string if the variant is either empty or its held value is <see langword="null"/>.
        ///     Otherwise, returns the value of calling <see cref="object.ToString"/> on the
        ///     held value.
        /// </returns>
        public override string? ToString()
        {
            return _type switch
            {
<#
        for (var i = 1; i <= currentTo; i++) {
#>
                VariantType.<#=T(i)#> => _value<#=i#> is null ? string.Empty : _value<#=i#>.ToString(),
<#
        }
#>
                _ => string.Empty
            };
        }
        
<#
        if (currentTo == 1) {
#>
        /// <summary>
        ///     Returns a new <see cref="Optional{T}"/> which represents the same state as the variant,
        ///     i.e. it holds a value if the variant holds a value or it is empty if the variant is empty.
        /// </summary>
        /// <returns>
        ///     A new <see cref="Optional{T}"/> holding the variant's value if it holds one.
        ///     An empty <see cref="Optional{T}"/> if the variant is empty.
        /// </returns>
        /// <remarks>
        ///     The <see cref="Variant{T1}"/> essentially has the same functionality as an <see cref="Optional{T}"/>.
        ///     Both types either hold a value or are empty. Therefore, any <see cref="Optional{T}"/> can
        ///     easily be converted to a <see cref="Variant{T1}"/> and vice versa.
        ///     
        ///     Nevertheless, the two types serve different purposes. While an <see cref="Optional{T}"/> is mainly
        ///     designed for modeling the absence of a value, the variant family is designed for scenarios where
        ///     one needs to accept or provide an instance of one or many types, or none.
        ///     Depending on the use case, you may pick either type for your scenario. If you ever
        ///     need to switch between the two, you can use one of the available conversion methods.
        /// </remarks>
        public Optional<T1> ToOptional()
        {
            return IsValue1 ? new Optional<T1>(_value1) : Optional<T1>.Empty; 
        }

<#
        }
#>
        /// <summary>
        ///     Deconstructs the variant into its set of possible values, represented as
        ///     <see cref="Optional{T}"/> instances.
        /// </summary>
<#
        for (var i = From; i <= currentTo; i++) {
#>
        /// <param name="value<#=i#>">A parameter holding the value of type <typeparamref name="<#=T(i)#>"/> after the deconstruction.</param>
<#
        }
#>
        /// <remarks>
        ///     Deconstructing a variant returns the same result as accessing properties like <see cref="Value1"/>.
        ///     Nontheless, it can be incredibly useful to give context to the values which a variant holds,
        ///     because the variant's possible values can be named during deconstruction. This can make a huge
        ///     difference when trying to understand code.
        ///     For example, <c>Transfer(variant.GetValue1())</c> is much harder to understand than:
        ///     
        ///     <code>
        ///     (Optional&lt;double&gt; bankAccountBalance, _) = variant;
        ///     Transfer(bankAccountBalance.GetValue());
        ///     </code>
        /// </remarks>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public void Deconstruct(<#=TParameters(currentTo, index => $"out Optional<{T(index)}> value{index}")#>)
        {
<#
        for (var i = 1; i <= currentTo; i++) {
#>
            value<#=i#> = Value<#=i#>;
<#
        }
#>
        }

        /// <summary>
        ///     Returns a value indicating whether the two variant instances are equal.
        ///     See <see cref="Equals(in Variant<#=TXmlDefinition(currentTo)#>)"/> for additional information how the
        ///     equality comparison works.
        /// </summary>
        /// <param name="left">The first variant instance.</param>
        /// <param name="right">The second variant instance.</param>
        /// <returns>
        ///     <see langword="true"/> if the two variant instances are equal;
        ///     <see langword="false"/> if not.
        /// </returns>
        /// <seealso cref="Equals(in Variant<#=TXmlDefinition(currentTo)#>)"/>
        public static bool operator ==(in Variant<#=TDefinition(currentTo)#> left, in Variant<#=TDefinition(currentTo)#> right)
        {
            return left.Equals(right);
        }

        /// <summary>
        ///     Returns a value indicating whether the two variant instances are unequal.
        ///     See <see cref="Equals(in Variant<#=TXmlDefinition(currentTo)#>)"/> for additional information how the
        ///     equality comparison works.
        /// </summary>
        /// <param name="left">The first variant instance.</param>
        /// <param name="right">The second variant instance.</param>
        /// <returns>
        ///     <see langword="true"/> if the two variant instances are unequal;
        ///     <see langword="false"/> if not.
        /// </returns>
        /// <seealso cref="Equals(in Variant<#=TXmlDefinition(currentTo)#>)"/>
        public static bool operator !=(in Variant<#=TDefinition(currentTo)#> left, in Variant<#=TDefinition(currentTo)#> right)
        {
            return !(left == right);
        }

<#
        for (var i = From; i <= currentTo; i++) {
#>
        /// <summary>
        ///     Returns a new <see cref="Variant<#=TXmlDefinition(currentTo)#>"/> instance which holds the
        ///     specified <paramref name="value"/>.
        /// </summary>
        /// <param name="value">The value to be held by the variant.</param>
        public static implicit operator Variant<#=TDefinition(currentTo)#>(<#=T(i)#> value)
        {
            return new Variant<#=TDefinition(currentTo)#>(value);
        }

        /// <summary>
        ///     If the variant holds a value of type <typeparamref name="<#=T(i)#>"/>, returns that value.
        ///     Otherwise an exception is thrown.
        /// </summary>
        /// <returns>
        ///     The held value of type <typeparamref name="<#=T(i)#>"/> if the variant holds such a value.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        ///     The variant doesn't hold a value of type <typeparamref name="<#=T(i)#>"/>.
        /// </exception>
        /// <seealso cref="GetValue<#=i#>"/>
        public static explicit operator <#=T(i)#>(in Variant<#=TDefinition(currentTo)#> variant)
        {
            return variant.GetValue<#=i#>();
        }

<#
        }
#>
<#
        for (var i = From; i <= currentTo - 1; i++) {
#>
        /// <summary>
        ///     Implicitly converts the specified <paramref name="variant"/> to a <see cref="Variant<#=TXmlDefinition(currentTo)#>"/>,
        ///     by enhancing it with one or more additional type parameters.
        /// </summary>
        /// <param name="variant">The variant to be converted.</param>
        public static implicit operator Variant<#=TDefinition(currentTo)#>(in Variant<#=TDefinition(i)#> variant)
        {
            return variant._type switch
            {
<#
            for (var j = From; j <= i; j++) {
#>
                Variant<#=TDefinition(i)#>.VariantType.<#=T(j)#> => new Variant<#=TDefinition(currentTo)#>(variant._value<#=j#>),
<#
            }
#>
                _ => Empty
            };
        }

<#
        }
#>
    }
<#
}
#>

}
