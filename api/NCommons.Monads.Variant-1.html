<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Class Variant&lt;T1&gt;
   | NCommons </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Class Variant&lt;T1&gt;
   | NCommons ">
    <meta name="generator" content="docfx 2.45.0.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container-fluid">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="NCommons">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container-fluid hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container-fluid body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-9">
            <article class="content wrap" id="_content" data-uid="NCommons.Monads.Variant`1">
  
  
  <h1 id="NCommons_Monads_Variant_1" data-uid="NCommons.Monads.Variant`1" class="text-break">Class Variant&lt;T1&gt;
  </h1>
  <div class="markdown level0 summary"><p>A container which either holds a value of one of the generic type parameters or no value at all.
See remarks for details.</p>
</div>
  <div class="markdown level0 conceptual"></div>
  <div class="inheritance">
    <h5>Inheritance</h5>
    <div class="level0"><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.object">Object</a></div>
    <div class="level1"><span class="xref">Variant&lt;T1&gt;</span></div>
  </div>
  <div classs="implements">
    <h5>Implements</h5>
    <div><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.iequatable-1">IEquatable</a>&lt;<a class="xref" href="NCommons.Monads.Variant-1.html">Variant</a>&lt;T1&gt;&gt;</div>
  </div>
  <h6><strong>Namespace</strong>: <a class="xref" href="NCommons.Monads.html">NCommons.Monads</a></h6>
  <h6><strong>Assembly</strong>: NCommons.Monads.dll</h6>
  <h5 id="NCommons_Monads_Variant_1_syntax">Syntax</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed class Variant&lt;T1&gt; : ValueType, IEquatable&lt;Variant&lt;T1&gt;&gt;</code></pre>
  </div>
  <h5 class="typeParameters">Type Parameters</h5>
  <code><strong><span class="parametername">T1</span></strong></code>
  <p>A type which may be held by the variant.</p>

  <h2 id="NCommons_Monads_Variant_1_remarks">Remarks</h2>
  <div class="markdown level0 remarks"><h3>General Usage</h3>
<p>In essence, the <a class="xref" href="NCommons.Monads.Variant-1.html">Variant&lt;T1&gt;</a> is a utility class which simply acts
as a data storage for one out of multiple different values. In that sense, it is very
similar to unions in other programming languages, but with the difference that a variant
may also not hold any value at all, i.e. it might be empty.
In plain english, one would say that <em>&quot;A variant may hold one of these given values or none at all.&quot;</em>.</p>
<p>The variant is ideally used for methods which need to return exactly one of multiple values.
While newer versions of C# already seem to support such scenarios via tuples, they don't exactly
capture the same intent as a variant.
Two items of a tuple may, for example, have a value at the same time.
This is not possible with a variant.</p>
<p>As an example, imagine that you write a method which can return a <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.string">String</a>,
an <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.int32">Int32</a> or no value at all. However, there is one twist - both the <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.string">String</a>
and <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.int32">Int32</a> are allowed be <span class="xref">null</span>.
The first thought may be to use a tuple for encoding the return value, but then the user of the function
has a problem - he has no way to determine which of these values was the right one. Checking them for
<span class="xref">null</span> is not possible, because <span class="xref">null</span> is a valid value for
both items:</p>
<pre><code>// This returns &quot;Hello&quot;, i.e. a string. But &quot;null&quot; is also a valid value for the int?.
(string?, int?) GetTwoValues() =>
    (&quot;Hello&quot;, null);

var (s, i) = GetTwoValues();

if (s != null)
{
    Console.WriteLine(&quot;String: {0}&quot;, s);
}
else if (i != null)
{
    Console.WriteLine(&quot;Int: {0}&quot;, i);
}
else
{
    Console.WriteLine(&quot;The function returned neither a string nor an int.&quot;);
}</code></pre>
<p>The code above seems to work fine at first glance, but what happens, when <code>(null, null)</code>
is returned? The code will print <code>&quot;The function returned neither a string nor an int.&quot;</code>.
This may be entirely wrong though. In fact, the function may have returned a <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.string">String</a>
which just happened to be <span class="xref">null</span>. As you can see, it is impossible to correctly
encode the return value using a tuple.</p>
<p>This problem is exactly what the variant is for:</p>
<pre><code>Variant&lt;string?, int?> GetTwoValues() =>
    &quot;Hello&quot;;

var variant = GetTwoValues();
if (variant.HasValue1)
{
    Console.WriteLine(&quot;String: {0}&quot;, variant.Value1);
}
else if (variant.HasValue2)
{
    Console.WriteLine(&quot;Int: {0}&quot;, variant.Value2);
}
else /* if (!variant.HasValue) */
{
    Console.WriteLine(&quot;The function returned neither a string nor an int.&quot;);
}</code></pre>
<p>In addition to solving these problems, the variant also makes a developer's life easier
by providing multiple methods for easily accessing or switching the actual held value.
For example, the code above may be shortened to this:</p>
<pre><code>Variant&lt;string?, int?> GetTwoValues() =>
    &quot;Hello&quot;;

var variant = GetTwoValues().Match(
    s  => Console.WriteLine(&quot;String: {0}&quot;, s),
    i  => Console.WriteLine(&quot;Int: {0}&quot;, i),
    () => Console.WriteLine(&quot;The function returned neither a string nor an int.&quot;)
);</code></pre>
<p>It is also possible to use tuple-like deconstruction when interacting with variants.
In fact, any variant can be deconstructed into its set of possible values.
Note that these values are represented as <a class="xref" href="NCommons.Monads.Optional-1.html">Optional&lt;T&gt;</a> instances, because
again, <span class="xref">null</span> may be a possible value for any type.
Furthermore, if the variant is empty, none of these optionals will hold a value.</p>
<pre><code>Variant&lt;string?, int?> GetTwoValues() =>
    &quot;Hello&quot;;

(Optional&lt;string?> s, Optional&lt;int?> i) = GetTwoValues();

if (s.HasValue)
{
    Console.WriteLine(&quot;String: {0}&quot;, variant.GetValue());
}
else if (i.HasValue)
{
    Console.WriteLine(&quot;Int: {0}&quot;, variant.GetValue());
}
else
{
    Console.WriteLine(&quot;The function returned neither a string nor an int.&quot;);
}</code></pre>
<h3>Application Areas and Limitations</h3>
<p>The variant has been created to add pseudo-support for unions to C#.
Due to limited C# language support, the variant has a few limitations though.
For example, it is not possible to implicitly convert two variants having the same type parameters,
but in a different order, to and from each other. For example, the <code>Variant&lt;string, int&gt;</code>
and <code>Variant&lt;int, string&gt;</code> in theory represent the same set of values, but cannot
be assigned to each other.</p>
<p>To minimize confusion amonst users, it is recommended to only use a variant as the return value
of a function. This means that it can immediately be deconstructed and processed and is thus
going to provide the least amount of problems.</p>
<h3>Performance Notes</h3>
<p>All variant classes are value types (structs). Internally, the variants store each possible
type parameter as a separate field to avoid boxing value types. While this results in one
internal field for the <a class="xref" href="NCommons.Monads.Variant-1.html">Variant&lt;T1&gt;</a>, the <a class="xref" href="NCommons.Monads.Variant-8.html">Variant&lt;T1, T2, T3, T4, T5, T6, T7, T8&gt;</a>
has eight fields.
This results in a lot of data being copied when passing such a variant around.
This can be avoided by using the <code>in</code> modifier when using a variant as a parameter:</p>
<pre><code>// Try to use the &quot;in&quot; modifier whenever appropriate.
public void Fn(in Variant&lt;string, int> variant)
{
    // ...
}</code></pre>
</div>
  <h2 id="constructors">Constructors
  </h2>
  <a id="NCommons_Monads_Variant_1__ctor_" data-uid="NCommons.Monads.Variant`1.#ctor*"></a>
  <h3 id="NCommons_Monads_Variant_1__ctor__0_" data-uid="NCommons.Monads.Variant`1.#ctor(`0)">Variant(T1)</h3>
  <div class="markdown level1 summary"><p>Initializes a new <a class="xref" href="NCommons.Monads.Variant-1.html">Variant&lt;T1&gt;</a> instance which
holds the specified <code data-dev-comment-type="paramref" class="paramref">value</code> of type <code data-dev-comment-type="typeparamref" class="typeparamref">T1</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h4 class="declaration">Declaration</h4>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Variant(T1 value)</code></pre>
  </div>
  <h4 class="parameters">Parameters</h4>
  <span class="xref">T1</span>
  <code><strong><span class="parametername">value</span></strong></code>
  <p>The value to be held by the variant.</p>

  <h2 id="properties">Properties
  </h2>
  <a id="NCommons_Monads_Variant_1_Empty_" data-uid="NCommons.Monads.Variant`1.Empty*"></a>
  <h3 id="NCommons_Monads_Variant_1_Empty" data-uid="NCommons.Monads.Variant`1.Empty">Empty</h3>
  <div class="markdown level1 summary"><p>An empty <a class="xref" href="NCommons.Monads.Variant-1.html">Variant&lt;T1&gt;</a> instance which does not hold any value.
This is equivalent to an instance created via the parameterless constructor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h4 class="declaration">Declaration</h4>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static Variant&lt;T1&gt; Empty { get; }</code></pre>
  </div>
  <h4 id="NCommons_Monads_Variant_1_Empty_remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>Be aware that this property has a <code>ref readonly</code> return value.
In most cases, using this field instead of the parameterless constructor will be the
more performant choice.</p>
</div>
  <a id="NCommons_Monads_Variant_1_HasValue_" data-uid="NCommons.Monads.Variant`1.HasValue*"></a>
  <h3 id="NCommons_Monads_Variant_1_HasValue" data-uid="NCommons.Monads.Variant`1.HasValue">HasValue</h3>
  <div class="markdown level1 summary"><p>Gets a value indicating whether the variant holds a value of one of the generic type parameters.
This return <span class="xref">false</span> if the variant is empty, i.e. if it doesn't hold any value.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h4 class="declaration">Declaration</h4>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool HasValue { get; }</code></pre>
  </div>
  <h4 id="NCommons_Monads_Variant_1_HasValue_remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>The <a class="xref" href="NCommons.Monads.Variant-1.html#NCommons_Monads_Variant_1_HasValue">HasValue</a> property can be used to determine whether the variant is empty.</p>
<p>The following code segment demonstrates this behavior using a variant with two
type parameters:</p>
<pre><code>Variant&lt;string, int> stringVariant = &quot;Hello&quot;;
Variant&lt;string, int> intVariant = 123;
Variant&lt;string, int> emptyVariant = Variant&lt;string, int>.Empty;

Console.WriteLine(stringVariant.HasValue);
Console.WriteLine(intVariant.HasValue);
Console.WriteLine(emptyVariant.HasValue);

// Output:
// &quot;True&quot;
// &quot;True&quot;
// &quot;False&quot;</code></pre>
<p>The <a class="xref" href="NCommons.Monads.Variant-1.html#NCommons_Monads_Variant_1_HasValue">HasValue</a> property is ideally used in conjunction with methods like
<a class="xref" href="NCommons.Monads.Variant-1.html#NCommons_Monads_Variant_1_GetValue1">GetValue1()</a>.  You can, for example, use <a class="xref" href="NCommons.Monads.Variant-1.html#NCommons_Monads_Variant_1_HasValue">HasValue</a>
to safely determine whether methods like <a class="xref" href="NCommons.Monads.Variant-1.html#NCommons_Monads_Variant_1_GetValue1">GetValue1()</a> can be called
without leading to an exception.</p>
</div>
  <a id="NCommons_Monads_Variant_1_HasValue1_" data-uid="NCommons.Monads.Variant`1.HasValue1*"></a>
  <h3 id="NCommons_Monads_Variant_1_HasValue1" data-uid="NCommons.Monads.Variant`1.HasValue1">HasValue1</h3>
  <div class="markdown level1 summary"><p>Gets a value indicating whether the variant holds a value of type <code data-dev-comment-type="typeparamref" class="typeparamref">T1</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h4 class="declaration">Declaration</h4>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool HasValue1 { get; }</code></pre>
  </div>
  <h4 id="NCommons_Monads_Variant_1_HasValue1_remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>The <a class="xref" href="NCommons.Monads.Variant-1.html#NCommons_Monads_Variant_1_HasValue1">HasValue1</a> property can be used to determine whether the variant
holds a value of type <code data-dev-comment-type="typeparamref" class="typeparamref">T1</code>.</p>
<p>The following code segment demonstrates this behavior using a variant with two
type parameters:</p>
<pre><code>Variant&lt;string, int> stringVariant = &quot;Hello&quot;;
Variant&lt;string, int> intVariant = 123;
Variant&lt;string, int> emptyVariant = Variant&lt;string, int>.Empty;

Console.WriteLine(stringVariant.HasValue1);
Console.WriteLine(stringVariant.HasValue2);
Console.WriteLine(intVariant.HasValue1);
Console.WriteLine(intVariant.HasValue2);
Console.WriteLine(emptyVariant.HasValue1);
Console.WriteLine(emptyVariant.HasValue2);

// Output:
// &quot;True&quot;
// &quot;False&quot;
// &quot;False&quot;
// &quot;True&quot;
// &quot;False&quot;
// &quot;False&quot;</code></pre>
<p>The <a class="xref" href="NCommons.Monads.Variant-1.html#NCommons_Monads_Variant_1_HasValue1">HasValue1</a> property is ideally used in conjunction with methods like
<a class="xref" href="NCommons.Monads.Variant-1.html#NCommons_Monads_Variant_1_GetValue1">GetValue1()</a>. You can, for example, use <a class="xref" href="NCommons.Monads.Variant-1.html#NCommons_Monads_Variant_1_HasValue1">HasValue1</a>
to safely determine whether <a class="xref" href="NCommons.Monads.Variant-1.html#NCommons_Monads_Variant_1_GetValue1">GetValue1()</a> can be called without
leading to an exception.</p>
</div>
  <a id="NCommons_Monads_Variant_1_Value_" data-uid="NCommons.Monads.Variant`1.Value*"></a>
  <h3 id="NCommons_Monads_Variant_1_Value" data-uid="NCommons.Monads.Variant`1.Value">Value</h3>
  <div class="markdown level1 summary"><p>Gets an <a class="xref" href="NCommons.Monads.Optional-1.html">Optional&lt;T&gt;</a> which, if the variant holds a value of any of the
given type parameters, holds the same value.
Otherwise, the optional is empty.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h4 class="declaration">Declaration</h4>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Optional&lt;object&gt; Value { get; }</code></pre>
  </div>
  <h4 id="NCommons_Monads_Variant_1_Value_remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>The <a class="xref" href="NCommons.Monads.Variant-1.html#NCommons_Monads_Variant_1_Value">Value</a> property allows you to access the underlying value of the
variant if it is non-empty, independent of what exact type the variant holds.</p>
<p>The following code segment demonstrates this behavior using a variant with two
type parameters:</p>
<pre><code>Variant&lt;string, int> stringVariant = &quot;Hello&quot;;
Variant&lt;string, int> intVariant = 123;
Variant&lt;string, int> emptyVariant = Variant&lt;string, int>.Empty;

Console.WriteLine(stringVariant.HasValue);
Console.WriteLine(stringVariant.Value);
Console.WriteLine(intVariant.HasValue);
Console.WriteLine(intVariant.Value);
Console.WriteLine(emptyVariant.HasValue);
Console.WriteLine(emptyVariant.Value);

// Output:
// &quot;True&quot;
// &quot;Hello&quot;
// &quot;True&quot;
// &quot;123&quot;
// &quot;False&quot;
// &quot;&quot;</code></pre>
<p>This property can be very useful if you want to do pattern matching on a variant's
held value, or if you simply need to call a method like <code>ToString</code> on the
variant's held value.</p>
</div>
  <a id="NCommons_Monads_Variant_1_Value1_" data-uid="NCommons.Monads.Variant`1.Value1*"></a>
  <h3 id="NCommons_Monads_Variant_1_Value1" data-uid="NCommons.Monads.Variant`1.Value1">Value1</h3>
  <div class="markdown level1 summary"><p>Gets an <a class="xref" href="NCommons.Monads.Optional-1.html">Optional&lt;T&gt;</a> which, if the variant holds a value of type
<code data-dev-comment-type="typeparamref" class="typeparamref">T1</code>, holds the same value.
Otherwise, the optional is empty.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h4 class="declaration">Declaration</h4>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Optional&lt;T1&gt; Value1 { get; }</code></pre>
  </div>
  <h4 id="NCommons_Monads_Variant_1_Value1_remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>The <a class="xref" href="NCommons.Monads.Variant-1.html#NCommons_Monads_Variant_1_Value1">Value1</a> property allows you to safely access the variant's
held value of type <code data-dev-comment-type="typeparamref" class="typeparamref">T1</code>.
In comparison to <a class="xref" href="NCommons.Monads.Variant-1.html#NCommons_Monads_Variant_1_GetValue1">GetValue1()</a>, this property never throws an exception
if the variant doesn't hold a value of type <code data-dev-comment-type="typeparamref" class="typeparamref">T1</code>.
Instead, an empty <a class="xref" href="NCommons.Monads.Optional-1.html">Optional&lt;T&gt;</a> is returned, allowing you to safely
handle both the empty and non-empty case.</p>
<p>The following code segment demonstrates this behavior using a variant with two
type parameters:</p>
<pre><code>Variant&lt;string, int> stringVariant = &quot;Hello&quot;;
Variant&lt;string, int> intVariant = 123;
Variant&lt;string, int> emptyVariant = Variant&lt;string, int>.Empty;

Console.WriteLine(stringVariant.Value1.HasValue);
Console.WriteLine(stringVariant.Value2.HasValue);
Console.WriteLine(intVariant.Value1.HasValue);
Console.WriteLine(intVariant.Value2.HasValue);
Console.WriteLine(emptyVariant.Value1.HasValue);
Console.WriteLine(emptyVariant.Value2.HasValue);

// Output:
// &quot;True&quot;
// &quot;False&quot;
// &quot;False&quot;
// &quot;True&quot;
// &quot;False&quot;
// &quot;False&quot;</code></pre>
</div>
  <h2 id="methods">Methods
  </h2>
  <a id="NCommons_Monads_Variant_1_Deconstruct_" data-uid="NCommons.Monads.Variant`1.Deconstruct*"></a>
  <h3 id="NCommons_Monads_Variant_1_Deconstruct_NCommons_Monads_Optional__0___" data-uid="NCommons.Monads.Variant`1.Deconstruct(NCommons.Monads.Optional{`0}@)">Deconstruct(out Optional&lt;T1&gt;)</h3>
  <div class="markdown level1 summary"><p>Deconstructs the variant into its set of possible values, represented as
<a class="xref" href="NCommons.Monads.Optional-1.html">Optional&lt;T&gt;</a> instances.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h4 class="declaration">Declaration</h4>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Deconstruct(out Optional&lt;T1&gt; value1)</code></pre>
  </div>
  <h4 class="parameters">Parameters</h4>
  <a class="xref" href="NCommons.Monads.Optional-1.html">Optional</a>&lt;T1&gt;
  <code><strong><span class="parametername">value1</span></strong></code>
  <p>A parameter holding the value of type <code data-dev-comment-type="typeparamref" class="typeparamref">T1</code> after the deconstruction.</p>

  <h4 id="NCommons_Monads_Variant_1_Deconstruct_NCommons_Monads_Optional__0____remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>Deconstructing a variant returns the same result as accessing properties like <a class="xref" href="NCommons.Monads.Variant-1.html#NCommons_Monads_Variant_1_Value1">Value1</a>.
Nontheless, it can be incredibly useful to give context to the values which a variant holds,
because the variant's possible values can be named during deconstruction. This can make a huge
difference when trying to understand code.
For example, <code>Transfer(variant.GetValue1())</code> is much harder to understand than:</p>
<pre><code>(Optional&lt;double> bankAccountBalance, _) = variant;
Transfer(bankAccountBalance.GetValue());</code></pre>
</div>
  <a id="NCommons_Monads_Variant_1_Equals_" data-uid="NCommons.Monads.Variant`1.Equals*"></a>
  <h3 id="NCommons_Monads_Variant_1_Equals_NCommons_Monads_Variant__0___" data-uid="NCommons.Monads.Variant`1.Equals(NCommons.Monads.Variant{`0}@)">Equals(Variant&lt;T1&gt;)</h3>
  <div class="markdown level1 summary"><p>Returns a value indicating whether the variant or its held value is equal to another variant.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h4 class="declaration">Declaration</h4>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool Equals(in Variant&lt;T1&gt; other)</code></pre>
  </div>
  <h4 class="parameters">Parameters</h4>
  <a class="xref" href="NCommons.Monads.Variant-1.html">Variant</a>&lt;T1&gt;
  <code><strong><span class="parametername">other</span></strong></code>
  <p>Another <a class="xref" href="NCommons.Monads.Variant-1.html">Variant&lt;T1&gt;</a> instance to be compared with the variant.</p>

  <h4 class="returns">Returns</h4>
  <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.boolean">Boolean</a>
  <p><span class="xref">true</span> if the two variants are equal;
<span class="xref">false</span> if not.</p>

  <h4 id="NCommons_Monads_Variant_1_Equals_NCommons_Monads_Variant__0____remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>Two variants are considered equal if:</p>
<ul><li>
            They are both empty.
</li><li>
    They both hold a value of the same generic type parameter and the held values
    are considered equal by a default <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.collections.generic.equalitycomparer-1">EqualityComparer&lt;T&gt;</a> instance.
</li></ul>
<p>If the above conditions are not met, the two variants are considered to be unequal.</p>
</div>
  <a id="NCommons_Monads_Variant_1_Equals_" data-uid="NCommons.Monads.Variant`1.Equals*"></a>
  <h3 id="NCommons_Monads_Variant_1_Equals_System_Object_" data-uid="NCommons.Monads.Variant`1.Equals(System.Object)">Equals(Object)</h3>
  <div class="markdown level1 summary"><p>Returns a value indicating whether the variant or its held value is equal to
the specified object.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h4 class="declaration">Declaration</h4>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public override bool Equals(object obj)</code></pre>
  </div>
  <h4 class="parameters">Parameters</h4>
  <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.object">Object</a>
  <code><strong><span class="parametername">obj</span></strong></code>
  <p>An object to be compared with the variant.</p>

  <h4 class="returns">Returns</h4>
  <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.boolean">Boolean</a>
  <p><span class="xref">true</span> if the specified object is equal to the variant or its held value;
<span class="xref">false</span> if not.</p>

  <h4 id="NCommons_Monads_Variant_1_Equals_System_Object__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>See <a class="xref" href="NCommons.Monads.Variant-1.html#NCommons_Monads_Variant_1_Equals_NCommons_Monads_Variant__0___">Equals(Variant&lt;T1&gt;)</a> for additional
information on how the equality comparison works.</p>
</div>
  <h4 id="NCommons_Monads_Variant_1_Equals_System_Object__seealso">See Also</h4>
  <div class="seealso">
      <div><a class="xref" href="NCommons.Monads.Variant-1.html#NCommons_Monads_Variant_1_Equals_NCommons_Monads_Variant__0___">Equals(Variant&lt;T1&gt;)</a></div>
  </div>
  <a id="NCommons_Monads_Variant_1_GetHashCode_" data-uid="NCommons.Monads.Variant`1.GetHashCode*"></a>
  <h3 id="NCommons_Monads_Variant_1_GetHashCode" data-uid="NCommons.Monads.Variant`1.GetHashCode">GetHashCode()</h3>
  <div class="markdown level1 summary"><p>Returns a unique hash code for the current instance.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h4 class="declaration">Declaration</h4>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public override int GetHashCode()</code></pre>
  </div>
  <h4 class="returns">Returns</h4>
  <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.int32">Int32</a>
  <ul><li>
<code>-1</code> if the variant is empty.
</li><li>
<code>0</code> if the variant holds a value which is <span class="xref">null</span>.
</li><li>
    The hash code of the held value if it is not <span class="xref">null</span>.
</li></ul>

  <a id="NCommons_Monads_Variant_1_GetValue1_" data-uid="NCommons.Monads.Variant`1.GetValue1*"></a>
  <h3 id="NCommons_Monads_Variant_1_GetValue1" data-uid="NCommons.Monads.Variant`1.GetValue1">GetValue1()</h3>
  <div class="markdown level1 summary"><p>If the variant holds a value of type <code data-dev-comment-type="typeparamref" class="typeparamref">T1</code>, returns that value.
Otherwise an exception is thrown.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h4 class="declaration">Declaration</h4>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public T1 GetValue1()</code></pre>
  </div>
  <h4 class="returns">Returns</h4>
  <span class="xref">T1</span>
  <p>The held value of type <code data-dev-comment-type="typeparamref" class="typeparamref">T1</code> if the variant holds such a value.</p>

  <h4 id="NCommons_Monads_Variant_1_GetValue1_remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>The <a class="xref" href="NCommons.Monads.Variant-1.html#NCommons_Monads_Variant_1_GetValue1">GetValue1()</a> function should be used if you either know or must ensure
that a variant holds a value of a specific type.</p>
<p>The following code segment demonstrates this behavior using a variant with two
type parameters:</p>
<pre><code>Variant&lt;string, int> stringVariant = &quot;Hello&quot;;
Variant&lt;string, int> intVariant = 123;
Variant&lt;string, int> emptyVariant = Variant&lt;string, int>.Empty;

Console.WriteLine(stringVariant.GetValue1());
Console.WriteLine(stringVariant.GetValue2());
Console.WriteLine(intVariant.GetValue1());
Console.WriteLine(intVariant.GetValue2());
Console.WriteLine(emptyVariant.GetValue1());
Console.WriteLine(emptyVariant.GetValue2());

// Output:
// &quot;Hello&quot;
// InvalidOperationException
// InvalidOperationException
// &quot;123&quot;
// InvalidOperationException
// InvalidOperationException</code></pre>
</div>
  <h4 class="exceptions">Exceptions</h4>
  <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.invalidoperationexception">InvalidOperationException</a>
  <p>The variant doesn't hold a value of type <code data-dev-comment-type="typeparamref" class="typeparamref">T1</code>.</p>

  <a id="NCommons_Monads_Variant_1_GetValue1Or_" data-uid="NCommons.Monads.Variant`1.GetValue1Or*"></a>
  <h3 id="NCommons_Monads_Variant_1_GetValue1Or__0_" data-uid="NCommons.Monads.Variant`1.GetValue1Or(`0)">GetValue1Or(T1)</h3>
  <div class="markdown level1 summary"><p>If the variant holds a value of type <code data-dev-comment-type="typeparamref" class="typeparamref">T1</code>, returns that value.
Otherwise the specified <code data-dev-comment-type="paramref" class="paramref">substitute</code> value is returned.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h4 class="declaration">Declaration</h4>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public T1 GetValue1Or(T1 substitute)</code></pre>
  </div>
  <h4 class="parameters">Parameters</h4>
  <span class="xref">T1</span>
  <code><strong><span class="parametername">substitute</span></strong></code>
  <p>A value to be returned if the variant doesn't hold a value of type <code data-dev-comment-type="typeparamref" class="typeparamref">T1</code>.</p>

  <h4 class="returns">Returns</h4>
  <span class="xref">T1</span>
  <p>The held value of type <code data-dev-comment-type="typeparamref" class="typeparamref">T1</code> if the variant holds such a value.
<code data-dev-comment-type="paramref" class="paramref">substitute</code> otherwise.</p>

  <h4 id="NCommons_Monads_Variant_1_GetValue1Or__0__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p><a class="xref" href="NCommons.Monads.Variant-1.html#NCommons_Monads_Variant_1_GetValue1Or__0_">GetValue1Or(T1)</a> behaves similarly to <a class="xref" href="NCommons.Monads.Variant-1.html#NCommons_Monads_Variant_1_GetValue1OrDefault">GetValue1OrDefault()</a>,
with the exception that you can choose the result of the function if the variant
is empty.</p>
<p>The following code segment demonstrates this behavior using a variant with two
type parameters:</p>
<pre><code>Variant&lt;string, int> stringVariant = &quot;Hello&quot;;
Variant&lt;string, int> intVariant = 123;
Variant&lt;string, int> emptyVariant = Variant&lt;string, int>.Empty;

Console.WriteLine(stringVariant.GetValue1Or(&quot;Substitute&quot;));
Console.WriteLine(stringVariant.GetValue2Or(1337));
Console.WriteLine(intVariant.GetValue1Or(&quot;Substitute&quot;));
Console.WriteLine(intVariant.GetValue2Or(1337));
Console.WriteLine(emptyVariant.GetValue1Or(&quot;Substitute&quot;));
Console.WriteLine(emptyVariant.GetValue2Or(1337));

// Output:
// &quot;Hello&quot;
// &quot;1337&quot;
// &quot;Substitute&quot;
// &quot;123&quot;
// &quot;Substitute&quot;
// &quot;1337&quot;</code></pre>
</div>
  <a id="NCommons_Monads_Variant_1_GetValue1Or_" data-uid="NCommons.Monads.Variant`1.GetValue1Or*"></a>
  <h3 id="NCommons_Monads_Variant_1_GetValue1Or_System_Func__0__" data-uid="NCommons.Monads.Variant`1.GetValue1Or(System.Func{`0})">GetValue1Or(Func&lt;T1&gt;)</h3>
  <div class="markdown level1 summary"><p>If the variant holds a value of type <code data-dev-comment-type="typeparamref" class="typeparamref">T1</code>, returns that value.
Otherwise the value returned by the specified <code data-dev-comment-type="paramref" class="paramref">substituteProvider</code> function
is returned.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h4 class="declaration">Declaration</h4>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public T1 GetValue1Or(Func&lt;T1&gt; substituteProvider)</code></pre>
  </div>
  <h4 class="parameters">Parameters</h4>
  <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.func-1">Func</a>&lt;T1&gt;
  <code><strong><span class="parametername">substituteProvider</span></strong></code>
  <p>A function which returns a value which is supposed to be returned
if the variant doesn't hold a value of type <code data-dev-comment-type="typeparamref" class="typeparamref">T1</code>.</p>

  <h4 class="returns">Returns</h4>
  <span class="xref">T1</span>
  <p>The held value of type <code data-dev-comment-type="typeparamref" class="typeparamref">T1</code> if the variant holds such a value.
A value returned by <code data-dev-comment-type="paramref" class="paramref">substituteProvider</code> otherwise.</p>

  <h4 id="NCommons_Monads_Variant_1_GetValue1Or_System_Func__0___remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p><a class="xref" href="NCommons.Monads.Variant-1.html#NCommons_Monads_Variant_1_GetValue1Or_System_Func__0__">GetValue1Or(Func&lt;T1&gt;)</a> behaves similarly to <a class="xref" href="NCommons.Monads.Variant-1.html#NCommons_Monads_Variant_1_GetValue1OrDefault">GetValue1OrDefault()</a>,
with the exception that you can choose the result of the function if the variant
is empty.</p>
<p>The following code segment demonstrates this behavior using a variant with two
type parameters:</p>
<pre><code>Variant&lt;string, int> stringVariant = &quot;Hello&quot;;
Variant&lt;string, int> intVariant = 123;
Variant&lt;string, int> emptyVariant = Variant&lt;string, int>.Empty;

Console.WriteLine(stringVariant.GetValue1Or(() => &quot;Substitute&quot;));
Console.WriteLine(stringVariant.GetValue2Or(() => 1337));
Console.WriteLine(intVariant.GetValue1Or(() => &quot;Substitute&quot;));
Console.WriteLine(intVariant.GetValue2Or(() => 1337));
Console.WriteLine(emptyVariant.GetValue1Or(() => &quot;Substitute&quot;));
Console.WriteLine(emptyVariant.GetValue2Or(() => 1337));

// Output:
// &quot;Hello&quot;
// &quot;1337&quot;
// &quot;Substitute&quot;
// &quot;123&quot;
// &quot;Substitute&quot;
// &quot;1337&quot;</code></pre>
</div>
  <h4 class="exceptions">Exceptions</h4>
  <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.argumentnullexception">ArgumentNullException</a>
  <ul>
<li><code data-dev-comment-type="paramref" class="paramref">substituteProvider</code></li>
</ul>

  <a id="NCommons_Monads_Variant_1_GetValue1OrDefault_" data-uid="NCommons.Monads.Variant`1.GetValue1OrDefault*"></a>
  <h3 id="NCommons_Monads_Variant_1_GetValue1OrDefault" data-uid="NCommons.Monads.Variant`1.GetValue1OrDefault">GetValue1OrDefault()</h3>
  <div class="markdown level1 summary"><p>If the variant holds a value of type <code data-dev-comment-type="typeparamref" class="typeparamref">T1</code>, returns that value.
Otherwise the default value of the type <code data-dev-comment-type="typeparamref" class="typeparamref">T1</code> is returned.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h4 class="declaration">Declaration</h4>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public T1 GetValue1OrDefault()</code></pre>
  </div>
  <h4 class="returns">Returns</h4>
  <span class="xref">T1</span>
  <p>The held value of type <code data-dev-comment-type="typeparamref" class="typeparamref">T1</code> if the variant holds such a value.
The default value of the type <code data-dev-comment-type="typeparamref" class="typeparamref">T1</code> otherwise.</p>

  <h4 id="NCommons_Monads_Variant_1_GetValue1OrDefault_remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p><a class="xref" href="NCommons.Monads.Variant-1.html#NCommons_Monads_Variant_1_GetValue1OrDefault">GetValue1OrDefault()</a> is useful when you must retrieve a value of type
<code data-dev-comment-type="typeparamref" class="typeparamref">T1</code>, independent of whether that is a default value or not.</p>
<p>The following code segment demonstrates this behavior using a variant with two
type parameters:</p>
<pre><code>Variant&lt;string, int> stringVariant = &quot;Hello&quot;;
Variant&lt;string, int> intVariant = 123;
Variant&lt;string, int> emptyVariant = Variant&lt;string, int>.Empty;

Console.WriteLine(stringVariant.GetValue1OrDefault());
Console.WriteLine(stringVariant.GetValue2OrDefault());
Console.WriteLine(intVariant.GetValue1OrDefault());
Console.WriteLine(intVariant.GetValue2OrDefault());
Console.WriteLine(emptyVariant.GetValue1OrDefault());
Console.WriteLine(emptyVariant.GetValue2OrDefault());

// Output:
// &quot;Hello&quot;
// &quot;0&quot;
// &quot;null&quot;
// &quot;123&quot;
// &quot;null&quot;
// &quot;0&quot;</code></pre>
</div>
  <a id="NCommons_Monads_Variant_1_Match_" data-uid="NCommons.Monads.Variant`1.Match*"></a>
  <h3 id="NCommons_Monads_Variant_1_Match_System_Action__0__System_Action_" data-uid="NCommons.Monads.Variant`1.Match(System.Action{`0},System.Action)">Match(Action&lt;T1&gt;, Action)</h3>
  <div class="markdown level1 summary"><p>Executes one of the specified functions depending on which value the variant holds.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h4 class="declaration">Declaration</h4>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Match(Action&lt;T1&gt; onValue1, Action onEmpty)</code></pre>
  </div>
  <h4 class="parameters">Parameters</h4>
  <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;T1&gt;
  <code><strong><span class="parametername">onValue1</span></strong></code>
  <p>The function to be invoked if the variant holds a value of type <code data-dev-comment-type="typeparamref" class="typeparamref">T1</code>.</p>

  <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.action">Action</a>
  <code><strong><span class="parametername">onEmpty</span></strong></code>
  <p>The function to be invoked if the variant is empty.</p>

  <h4 id="NCommons_Monads_Variant_1_Match_System_Action__0__System_Action__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p><a class="xref" href="NCommons.Monads.Variant-1.html#NCommons_Monads_Variant_1_Match_System_Action__0__System_Action_">Match(Action&lt;T1&gt;, Action)</a> is a utility function
which allows you to invoke one of multiple functions, depending on which value a variant
currently holds.</p>
<p>The following code segment demonstrates this behavior using a variant with two
type parameters:</p>
<pre><code>static void Print(Variant&lt;string, int> variant) =>
    variant.Match(
        str    => Console.WriteLine(&quot;string: {0}&quot;, str),
        number => Console.WriteLine(&quot;int: {0}&quot;, number),
        ()     => Console.WriteLine(&quot;Empty&quot;)
    );

Variant&lt;string, int> stringVariant = &quot;Hello&quot;;
Variant&lt;string, int> intVariant = 123;
Variant&lt;string, int> emptyVariant = Variant&lt;string, int>.Empty;

Print(stringVariant);
Print(intVariant);
Print(emptyVariant);

// Output:
// &quot;string: Hello&quot;
// &quot;int: 123&quot;
// &quot;Empty&quot;</code></pre>
</div>
  <h4 class="exceptions">Exceptions</h4>
  <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.argumentnullexception">ArgumentNullException</a>
  <ul>
<li><code data-dev-comment-type="paramref" class="paramref">onValue1</code></li>
<li><code data-dev-comment-type="paramref" class="paramref">onEmpty</code></li>
</ul>

  <a id="NCommons_Monads_Variant_1_Match_" data-uid="NCommons.Monads.Variant`1.Match*"></a>
  <h3 id="NCommons_Monads_Variant_1_Match__1_System_Func__0___0__System_Func___0__" data-uid="NCommons.Monads.Variant`1.Match``1(System.Func{`0,``0},System.Func{``0})">Match&lt;TResult&gt;(Func&lt;T1, TResult&gt;, Func&lt;TResult&gt;)</h3>
  <div class="markdown level1 summary"><p>Executes one of the specified functions depending on which value the variant holds
and returns that function's return value.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h4 class="declaration">Declaration</h4>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TResult Match&lt;TResult&gt;(Func&lt;T1, TResult&gt; onValue1, Func&lt;TResult&gt; onEmpty)</code></pre>
  </div>
  <h4 class="parameters">Parameters</h4>
  <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.func-2">Func</a>&lt;T1, TResult&gt;
  <code><strong><span class="parametername">onValue1</span></strong></code>
  <p>The function to be invoked if the variant holds a value of type <code data-dev-comment-type="typeparamref" class="typeparamref">T1</code>.</p>

  <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.func-1">Func</a>&lt;TResult&gt;
  <code><strong><span class="parametername">onEmpty</span></strong></code>
  <p>The function to be invoked if the variant is empty.</p>

  <h4 class="returns">Returns</h4>
  <span class="xref">TResult</span>
  
  <h4 class="typeParameters">Type Parameters</h4>
  <code><strong><span class="parametername">TResult</span></strong></code>
  
  <h4 id="NCommons_Monads_Variant_1_Match__1_System_Func__0___0__System_Func___0___remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p><a class="xref" href="NCommons.Monads.Variant-1.html#NCommons_Monads_Variant_1_Match_System_Action__0__System_Action_">Match(Action&lt;T1&gt;, Action)</a> is a utility function
which allows you to invoke one of multiple functions, depending on which value a variant
currently holds.</p>
<p>In comparison to the <a class="xref" href="NCommons.Monads.Variant-1.html#NCommons_Monads_Variant_1_Match_System_Action__0__System_Action_">Match(Action&lt;T1&gt;, Action)</a>
overload, this method supports returning a value.</p>
<p>The following code segment demonstrates this behavior using a variant with two
type parameters:</p>
<pre><code>static string Stringify(Variant&lt;string, int> variant) =>
    variant.Match(
        str    => $&quot;string: {str}&quot;,
        number => $&quot;int: {number}&quot;,
        ()     => $&quot;Empty&quot;
    );

Variant&lt;string, int> stringVariant = &quot;Hello&quot;;
Variant&lt;string, int> intVariant = 123;
Variant&lt;string, int> emptyVariant = Variant&lt;string, int>.Empty;

Console.WriteLine(Stringify(stringVariant));
Console.WriteLine(Stringify(intVariant));
Console.WriteLine(Stringify(emptyVariant));

// Output:
// &quot;string: Hello&quot;
// &quot;int: 123&quot;
// &quot;Empty&quot;</code></pre>
</div>
  <h4 class="exceptions">Exceptions</h4>
  <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.argumentnullexception">ArgumentNullException</a>
  <ul>
<li><code data-dev-comment-type="paramref" class="paramref">onValue1</code></li>
<li><code data-dev-comment-type="paramref" class="paramref">onEmpty</code></li>
</ul>

  <a id="NCommons_Monads_Variant_1_ToOptional_" data-uid="NCommons.Monads.Variant`1.ToOptional*"></a>
  <h3 id="NCommons_Monads_Variant_1_ToOptional" data-uid="NCommons.Monads.Variant`1.ToOptional">ToOptional()</h3>
  <div class="markdown level1 summary"><p>Returns a new <a class="xref" href="NCommons.Monads.Optional-1.html">Optional&lt;T&gt;</a> which represents the same state as the variant,
i.e. it holds a value if the variant holds a value or it is empty if the variant is empty.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h4 class="declaration">Declaration</h4>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Optional&lt;T1&gt; ToOptional()</code></pre>
  </div>
  <h4 class="returns">Returns</h4>
  <a class="xref" href="NCommons.Monads.Optional-1.html">Optional</a>&lt;T1&gt;
  <p>A new <a class="xref" href="NCommons.Monads.Optional-1.html">Optional&lt;T&gt;</a> holding the variant's value if it holds one.
An empty <a class="xref" href="NCommons.Monads.Optional-1.html">Optional&lt;T&gt;</a> if the variant is empty.</p>

  <h4 id="NCommons_Monads_Variant_1_ToOptional_remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>The <a class="xref" href="NCommons.Monads.Variant-1.html">Variant&lt;T1&gt;</a> essentially has the same functionality as an <a class="xref" href="NCommons.Monads.Optional-1.html">Optional&lt;T&gt;</a>.
Both types either hold a value or are empty. Therefore, any <a class="xref" href="NCommons.Monads.Optional-1.html">Optional&lt;T&gt;</a> can
easily be converted to a <a class="xref" href="NCommons.Monads.Variant-1.html">Variant&lt;T1&gt;</a> and vice versa.</p>
<p>Nevertheless, the two types serve different purposes. While an <a class="xref" href="NCommons.Monads.Optional-1.html">Optional&lt;T&gt;</a> is mainly
designed for modeling the absence of a value, the variant family is designed for scenarios where
one needs to accept or provide an instance of one or many types, or none.
Depending on the use case, you may pick either type for your scenario. If you ever
need to switch between the two, you can use one of the available conversion methods.</p>
</div>
  <a id="NCommons_Monads_Variant_1_ToString_" data-uid="NCommons.Monads.Variant`1.ToString*"></a>
  <h3 id="NCommons_Monads_Variant_1_ToString" data-uid="NCommons.Monads.Variant`1.ToString">ToString()</h3>
  <div class="markdown level1 summary"><p>Returns a string representation of the variant or its held value.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h4 class="declaration">Declaration</h4>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public override string ToString()</code></pre>
  </div>
  <h4 class="returns">Returns</h4>
  <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.string">String</a>
  <p>An empty string if the variant is either empty or its held value is <span class="xref">null</span>.
Otherwise, returns the value of calling <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.object.tostring#System_Object_ToString">ToString()</a> on the
held value.</p>

  <a id="NCommons_Monads_Variant_1_TryGetValue1_" data-uid="NCommons.Monads.Variant`1.TryGetValue1*"></a>
  <h3 id="NCommons_Monads_Variant_1_TryGetValue1__0__" data-uid="NCommons.Monads.Variant`1.TryGetValue1(`0@)">TryGetValue1(out T1)</h3>
  <div class="markdown level1 summary"><p>Attempts to retrieve a value of type <code data-dev-comment-type="typeparamref" class="typeparamref">T1</code> from the variant
and returns a value indicating whether the retrieval was successful, i.e. if the variant
actually held a value of that type.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h4 class="declaration">Declaration</h4>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool TryGetValue1(out T1 value)</code></pre>
  </div>
  <h4 class="parameters">Parameters</h4>
  <span class="xref">T1</span>
  <code><strong><span class="parametername">value</span></strong></code>
  <p>A parameter which will hold the value of type <code data-dev-comment-type="typeparamref" class="typeparamref">T1</code> if
the variant held one.</p>

  <h4 class="returns">Returns</h4>
  <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.boolean">Boolean</a>
  <p><span class="xref">true</span> if the variant held a value of type <code data-dev-comment-type="typeparamref" class="typeparamref">T1</code>.
<span class="xref">false</span> otherwise.</p>

  <h2 id="operators">Operators
  </h2>
  <a id="NCommons_Monads_Variant_1_op_Equality_" data-uid="NCommons.Monads.Variant`1.op_Equality*"></a>
  <h3 id="NCommons_Monads_Variant_1_op_Equality_NCommons_Monads_Variant__0___NCommons_Monads_Variant__0___" data-uid="NCommons.Monads.Variant`1.op_Equality(NCommons.Monads.Variant{`0}@,NCommons.Monads.Variant{`0}@)">Equality(Variant&lt;T1&gt;, Variant&lt;T1&gt;)</h3>
  <div class="markdown level1 summary"><p>Returns a value indicating whether the two variant instances are equal.
See <a class="xref" href="NCommons.Monads.Variant-1.html#NCommons_Monads_Variant_1_Equals_NCommons_Monads_Variant__0___">Equals(Variant&lt;T1&gt;)</a> for additional information how the
equality comparison works.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h4 class="declaration">Declaration</h4>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static bool operator ==(in Variant&lt;T1&gt; left, in Variant&lt;T1&gt; right)</code></pre>
  </div>
  <h4 class="parameters">Parameters</h4>
  <a class="xref" href="NCommons.Monads.Variant-1.html">Variant</a>&lt;T1&gt;
  <code><strong><span class="parametername">left</span></strong></code>
  <p>The first variant instance.</p>

  <a class="xref" href="NCommons.Monads.Variant-1.html">Variant</a>&lt;T1&gt;
  <code><strong><span class="parametername">right</span></strong></code>
  <p>The second variant instance.</p>

  <h4 class="returns">Returns</h4>
  <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.boolean">Boolean</a>
  <p><span class="xref">true</span> if the two variant instances are equal;
<span class="xref">false</span> if not.</p>

  <h4 id="NCommons_Monads_Variant_1_op_Equality_NCommons_Monads_Variant__0___NCommons_Monads_Variant__0____seealso">See Also</h4>
  <div class="seealso">
      <div><a class="xref" href="NCommons.Monads.Variant-1.html#NCommons_Monads_Variant_1_Equals_NCommons_Monads_Variant__0___">Equals(Variant&lt;T1&gt;)</a></div>
  </div>
  <a id="NCommons_Monads_Variant_1_op_Explicit_" data-uid="NCommons.Monads.Variant`1.op_Explicit*"></a>
  <h3 id="NCommons_Monads_Variant_1_op_Explicit_NCommons_Monads_Variant__0_____0" data-uid="NCommons.Monads.Variant`1.op_Explicit(NCommons.Monads.Variant{`0}@)~`0">Explicit(Variant&lt;T1&gt; to T1)</h3>
  <div class="markdown level1 summary"><p>If the variant holds a value of type <code data-dev-comment-type="typeparamref" class="typeparamref">T1</code>, returns that value.
Otherwise an exception is thrown.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h4 class="declaration">Declaration</h4>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static explicit operator T1(in Variant&lt;T1&gt; variant)</code></pre>
  </div>
  <h4 class="parameters">Parameters</h4>
  <a class="xref" href="NCommons.Monads.Variant-1.html">Variant</a>&lt;T1&gt;
  <code><strong><span class="parametername">variant</span></strong></code>
  
  <h4 class="returns">Returns</h4>
  <span class="xref">T1</span>
  <p>The held value of type <code data-dev-comment-type="typeparamref" class="typeparamref">T1</code> if the variant holds such a value.</p>

  <h4 class="exceptions">Exceptions</h4>
  <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.invalidoperationexception">InvalidOperationException</a>
  <p>The variant doesn't hold a value of type <code data-dev-comment-type="typeparamref" class="typeparamref">T1</code>.</p>

  <h4 id="NCommons_Monads_Variant_1_op_Explicit_NCommons_Monads_Variant__0_____0_seealso">See Also</h4>
  <div class="seealso">
      <div><a class="xref" href="NCommons.Monads.Variant-1.html#NCommons_Monads_Variant_1_GetValue1">GetValue1()</a></div>
  </div>
  <a id="NCommons_Monads_Variant_1_op_Implicit_" data-uid="NCommons.Monads.Variant`1.op_Implicit*"></a>
  <h3 id="NCommons_Monads_Variant_1_op_Implicit__0__NCommons_Monads_Variant__0_" data-uid="NCommons.Monads.Variant`1.op_Implicit(`0)~NCommons.Monads.Variant{`0}">Implicit(T1 to Variant&lt;T1&gt;)</h3>
  <div class="markdown level1 summary"><p>Returns a new <a class="xref" href="NCommons.Monads.Variant-1.html">Variant&lt;T1&gt;</a> instance which holds the
specified <code data-dev-comment-type="paramref" class="paramref">value</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h4 class="declaration">Declaration</h4>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static implicit operator Variant&lt;T1&gt;(T1 value)</code></pre>
  </div>
  <h4 class="parameters">Parameters</h4>
  <span class="xref">T1</span>
  <code><strong><span class="parametername">value</span></strong></code>
  <p>The value to be held by the variant.</p>

  <h4 class="returns">Returns</h4>
  <a class="xref" href="NCommons.Monads.Variant-1.html">Variant</a>&lt;T1&gt;
  
  <a id="NCommons_Monads_Variant_1_op_Inequality_" data-uid="NCommons.Monads.Variant`1.op_Inequality*"></a>
  <h3 id="NCommons_Monads_Variant_1_op_Inequality_NCommons_Monads_Variant__0___NCommons_Monads_Variant__0___" data-uid="NCommons.Monads.Variant`1.op_Inequality(NCommons.Monads.Variant{`0}@,NCommons.Monads.Variant{`0}@)">Inequality(Variant&lt;T1&gt;, Variant&lt;T1&gt;)</h3>
  <div class="markdown level1 summary"><p>Returns a value indicating whether the two variant instances are unequal.
See <a class="xref" href="NCommons.Monads.Variant-1.html#NCommons_Monads_Variant_1_Equals_NCommons_Monads_Variant__0___">Equals(Variant&lt;T1&gt;)</a> for additional information how the
equality comparison works.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h4 class="declaration">Declaration</h4>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static bool operator !=(in Variant&lt;T1&gt; left, in Variant&lt;T1&gt; right)</code></pre>
  </div>
  <h4 class="parameters">Parameters</h4>
  <a class="xref" href="NCommons.Monads.Variant-1.html">Variant</a>&lt;T1&gt;
  <code><strong><span class="parametername">left</span></strong></code>
  <p>The first variant instance.</p>

  <a class="xref" href="NCommons.Monads.Variant-1.html">Variant</a>&lt;T1&gt;
  <code><strong><span class="parametername">right</span></strong></code>
  <p>The second variant instance.</p>

  <h4 class="returns">Returns</h4>
  <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.boolean">Boolean</a>
  <p><span class="xref">true</span> if the two variant instances are unequal;
<span class="xref">false</span> if not.</p>

  <h4 id="NCommons_Monads_Variant_1_op_Inequality_NCommons_Monads_Variant__0___NCommons_Monads_Variant__0____seealso">See Also</h4>
  <div class="seealso">
      <div><a class="xref" href="NCommons.Monads.Variant-1.html#NCommons_Monads_Variant_1_Equals_NCommons_Monads_Variant__0___">Equals(Variant&lt;T1&gt;)</a></div>
  </div>
  <h2 id="implements">Implements</h2>
  <div>
      <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.iequatable-1">System.IEquatable&lt;T&gt;</a>
  </div>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container-fluid">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            Copyright &copy; 2019 Manuel Römer - Generated with <a href="https://github.com/dotnet/docfx">DocFX</a> - <a href="https://gist.github.com/manuelroemer/2aa8fc4e377874ae93dbd26e779cdbf6">Impressum (Imprint)</a>
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
